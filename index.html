<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç²’å­åœŸæ˜Ÿ | äº¤äº’å¼å¤ªç©ºä½“éªŒ</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        :root {
            --primary-gold: #c5a059;
            --deep-space: #050505;
            --ui-bg: rgba(5, 5, 5, 0.7);
            --transition-speed: 0.4s;
        }
        
        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--deep-space);
            font-family: 'Microsoft YaHei', 'Segoe UI', sans-serif;
            color: white;
            user-select: none;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            background: radial-gradient(circle at center, #050505 0%, #0b0b10 100%);
        }

        #ui-layer {
            position: absolute;
            top: 30px;
            left: 30px;
            z-index: 10;
            pointer-events: none;
            transition: opacity var(--transition-speed);
        }

        .glass-panel {
            background: var(--ui-bg);
            backdrop-filter: blur(12px);
            padding: 24px;
            border-radius: 8px;
            border-left: 2px solid var(--primary-gold);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.9);
            max-width: 280px;
            transition: transform var(--transition-speed);
        }

        .glass-panel:hover {
            transform: translateY(-5px);
        }

        h1 {
            font-weight: 200;
            font-size: 1.8rem;
            margin: 0 0 10px 0;
            color: #e0cda7;
            letter-spacing: 4px;
            text-transform: uppercase;
        }

        .status-text {
            font-size: 0.85rem;
            color: #888;
            line-height: 1.6;
            font-family: monospace;
        }

        .highlight {
            color: var(--primary-gold);
            font-weight: bold;
        }

        #controls {
            position: absolute;
            bottom: 40px;
            right: 40px;
            z-index: 10;
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        #author-btn {
            position: absolute;
            top: 40px;
            right: 40px;
            z-index: 20;
            pointer-events: auto;
            text-decoration: none;
            color: var(--primary-gold);
            border: 1px solid rgba(197, 160, 89, 0.4);
            background: rgba(0, 0, 0, 0.6);
            padding: 8px 20px;
            font-size: 0.8rem;
            border-radius: 20px;
            transition: all 0.3s ease;
            backdrop-filter: blur(4px);
            letter-spacing: 1px;
            font-family: monospace;
        }

        #author-btn:hover {
            background: var(--primary-gold);
            color: #000;
            box-shadow: 0 0 15px rgba(197, 160, 89, 0.4);
        }

        button {
            background: transparent;
            border: 1px solid rgba(197, 160, 89, 0.3);
            color: var(--primary-gold);
            padding: 12px 30px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.4s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
            border-radius: 4px;
            backdrop-filter: blur(4px);
        }

        button:hover {
            background: rgba(197, 160, 89, 0.1);
            border-color: var(--primary-gold);
            box-shadow: 0 0 15px rgba(197, 160, 89, 0.2);
        }

        button.active {
            background: rgba(197, 160, 89, 0.2);
            border-color: var(--primary-gold);
            box-shadow: 0 0 10px rgba(197, 160, 89, 0.3);
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 20;
            text-align: center;
            color: #444;
            font-size: 0.8rem;
            letter-spacing: 3px;
            text-transform: uppercase;
            transition: opacity 0.5s;
        }
        
        #fps-counter {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #666;
            font-family: monospace;
            font-size: 10px;
            z-index: 5;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 3px;
        }

        #performance-panel {
            position: absolute;
            bottom: 40px;
            left: 30px;
            z-index: 10;
            pointer-events: auto;
        }

        .performance-option {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            cursor: pointer;
        }

        .performance-option input {
            margin-right: 10px;
        }

        .performance-option label {
            font-size: 0.8rem;
            color: #aaa;
            cursor: pointer;
        }

        #gesture-guide {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 15;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            max-width: 300px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(197, 160, 89, 0.3);
            transition: opacity 0.5s;
        }

        #gesture-guide.hidden {
            opacity: 0;
            pointer-events: none;
        }

        #gesture-guide h3 {
            color: var(--primary-gold);
            margin-top: 0;
        }

        .gesture-demo {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
        }

        .gesture-item {
            text-align: center;
        }

        .gesture-icon {
            width: 60px;
            height: 60px;
            background: rgba(197, 160, 89, 0.1);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 10px;
            font-size: 24px;
        }

        .input_video { 
            display: none; 
        }

        #info-panel {
            position: absolute;
            top: 30px;
            right: 150px;
            z-index: 10;
            pointer-events: none;
            opacity: 0;
            transition: opacity var(--transition-speed);
        }

        #info-panel.visible {
            opacity: 1;
        }

        .notification {
            background: var(--ui-bg);
            backdrop-filter: blur(12px);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 10px;
            border-left: 2px solid var(--primary-gold);
            max-width: 250px;
            font-size: 0.8rem;
        }

        #camera-permission {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 25;
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            max-width: 400px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(197, 160, 89, 0.3);
        }

        #camera-permission.hidden {
            display: none;
        }

        #camera-permission h3 {
            color: var(--primary-gold);
            margin-top: 0;
        }

        #hand-preview {
            width: 200px;
            height: 150px;
            background: rgba(255, 255, 255, 0.05);
            margin: 15px auto;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #888;
            font-size: 14px;
        }
    </style>
</head>
<body>

    <video class="input_video"></video>
    
    <!-- ä½œè€…è·³è½¬æŒ‰é’® -->
    <a id="author-btn" href="https://www.yjln.com" target="_blank">By Cannis_GU</a>

    <div id="fps-counter">FPS: -- | ç²’å­æ•°: --</div>

    <div id="loading">
        æ­£åœ¨åˆå§‹åŒ–ç²’å­ç³»ç»Ÿ...
    </div>

    <div id="camera-permission">
        <h3>æ‘„åƒå¤´æƒé™è¯·æ±‚</h3>
        <p>ä¸ºäº†ä½¿ç”¨æ‰‹åŠ¿æ§åˆ¶åŠŸèƒ½ï¼Œè¯·å…è®¸è®¿é—®æ‚¨çš„æ‘„åƒå¤´</p>
        <div id="hand-preview">æ‰‹éƒ¨é¢„è§ˆåŒºåŸŸ</div>
        <button onclick="requestCameraPermission()">å…è®¸æ‘„åƒå¤´è®¿é—®</button>
        <p style="font-size: 12px; margin-top: 15px; color: #888;">æˆ–è€…æ‚¨å¯ä»¥é€‰æ‹©è·³è¿‡ï¼Œä½¿ç”¨è‡ªåŠ¨æ¼”ç¤ºæ¨¡å¼</p>
        <button onclick="skipCameraPermission()" style="background: transparent; border: 1px solid #666; color: #888; margin-top: 10px;">è·³è¿‡æ‰‹åŠ¿æ§åˆ¶</button>
    </div>

    <div id="gesture-guide" class="hidden">
        <h3>æ‰‹åŠ¿æ§åˆ¶æŒ‡å—</h3>
        <p>ä½¿ç”¨æ‰‹åŠ¿ä¸åœŸæ˜Ÿäº’åŠ¨ï¼š</p>
        <div class="gesture-demo">
            <div class="gesture-item">
                <div class="gesture-icon">ğŸ‘†</div>
                <div>æåˆç¼©æ”¾</div>
            </div>
            <div class="gesture-item">
                <div class="gesture-icon">ğŸ‘‹</div>
                <div>æ‰‹æŒç§»åŠ¨æ—‹è½¬</div>
            </div>
        </div>
        <button onclick="hideGestureGuide()">å¼€å§‹æ¢ç´¢</button>
    </div>

    <div id="ui-layer">
        <div class="glass-panel">
            <h1>åœŸæ˜Ÿ</h1>
            <div class="status-text">
                æ•°æ®æµçŠ¶æ€: <span id="status-indicator" class="highlight">å¾…æœº</span>
                <br><br>
                > å¼€æ™®å‹’è½¨é“: è¿è¡Œä¸­<br>
                > ç²’å­æ€»æ•°: <span id="particle-count">60ä¸‡+</span><br>
                > æ€§èƒ½æ¨¡å¼: <span id="performance-mode">å¹³è¡¡</span>
            </div>
        </div>
    </div>

    <div id="info-panel">
        <div class="notification">
            <strong>æ¢ç´¢æç¤º</strong><br>
            å°è¯•ç”¨æ‰‹åŠ¿æ§åˆ¶åœŸæ˜Ÿçš„ç¼©æ”¾å’Œæ—‹è½¬
        </div>
    </div>

    <div id="performance-panel">
        <div class="glass-panel">
            <h3>æ€§èƒ½è®¾ç½®</h3>
            <div class="performance-option">
                <input type="radio" id="performance-low" name="performance" value="low">
                <label for="performance-low">èŠ‚èƒ½æ¨¡å¼ (30ä¸‡ç²’å­)</label>
            </div>
            <div class="performance-option">
                <input type="radio" id="performance-medium" name="performance" value="medium" checked>
                <label for="performance-medium">å¹³è¡¡æ¨¡å¼ (60ä¸‡ç²’å­)</label>
            </div>
            <div class="performance-option">
                <input type="radio" id="performance-high" name="performance" value="high">
                <label for="performance-high">æè‡´æ¨¡å¼ (90ä¸‡ç²’å­)</label>
            </div>
        </div>
    </div>

    <div id="controls">
        <button onclick="toggleFullScreen()">å…¨å±ä½“éªŒ</button>
        <button id="toggle-ui" onclick="toggleUI()">éšè—ç•Œé¢</button>
        <button id="reset-view" onclick="resetView()">é‡ç½®è§†è§’</button>
        <button id="toggle-hand-tracking" onclick="toggleHandTracking()">å¼€å¯æ‰‹åŠ¿æ§åˆ¶</button>
    </div>

    <div id="canvas-container"></div>

    <!-- ç€è‰²å™¨ä»£ç ä¿æŒä¸å˜ -->
    <script type="x-shader/x-vertex" id="vertexshader">
        attribute float size;
        attribute vec3 customColor;
        attribute float opacityAttr;
        attribute float orbitSpeed;
        attribute float isRing;
        attribute float aRandomId;
        
        varying vec3 vColor;
        varying float vDist;
        varying float vOpacity;
        varying float vScaleFactor;
        varying float vIsRing;
        
        uniform float uTime;
        uniform float uScale;
        uniform float uRotationX;
        
        // 2D æ—‹è½¬çŸ©é˜µ
        mat2 rotate2d(float _angle){
            return mat2(cos(_angle),-sin(_angle),
                        sin(_angle),cos(_angle));
        }

        // ç®€å•çš„å“ˆå¸Œå‡½æ•°ï¼Œç”¨æ¥åšéšæœº
        float hash(float n) { return fract(sin(n) * 43758.5453123); }

        void main() {
            // æ ¹æ®ç¼©æ”¾çº§åˆ«åš LOD (ç»†èŠ‚å±‚æ¬¡) å‰”é™¤
            float normScaleLOD = clamp((uScale - 0.15) / 2.35, 0.0, 1.0);
            float visibilityThreshold = 0.9 + pow(normScaleLOD, 1.2) * 0.1; 

            // å¦‚æœéšæœºIDå¤§äºé˜ˆå€¼ï¼Œç›´æ¥æŠŠç‚¹æ‰”å‡ºå±å¹•ï¼Œçœæ˜¾å¡èµ„æº
            if (aRandomId > visibilityThreshold) {
                gl_Position = vec4(0.0);
                gl_PointSize = 0.0;
                return;
            }

            vec3 pos = position;

            // è®©å…‰ç¯å’Œæœ¬ä½“åˆ†å¼€æ—‹è½¬ï¼Œå¢åŠ åŠ¨æ€æ„Ÿ
            if (isRing > 0.5) {
                float angleOffset = uTime * orbitSpeed * 0.2;
                vec2 rotatedXZ = rotate2d(angleOffset) * pos.xz;
                pos.x = rotatedXZ.x;
                pos.z = rotatedXZ.y;
            } else {
                float bodyAngle = uTime * 0.03;
                vec2 rotatedXZ = rotate2d(bodyAngle) * pos.xz;
                pos.x = rotatedXZ.x;
                pos.z = rotatedXZ.y;
            }

            // å¤„ç†æ•´ä½“è§†è§’çš„ X è½´æ—‹è½¬ï¼ˆå³æ‰‹åŠ¿æ§åˆ¶çš„ä¿¯ä»°è§’ï¼‰
            float cx = cos(uRotationX);
            float sx = sin(uRotationX);
            float ry = pos.y * cx - pos.z * sx;
            float rz = pos.y * sx + pos.z * cx;
            pos.y = ry;
            pos.z = rz;

            // è½¬æ¢åˆ°ç›¸æœºç©ºé—´
            vec4 mvPosition = modelViewMatrix * vec4(pos * uScale, 1.0);
            float dist = -mvPosition.z;
            vDist = dist;

            // --- æ··æ²Œå™ªç‚¹æ•ˆæœ ---
            // å½“æ‘„åƒæœºè´´å¾—å¾ˆè¿‘æ—¶ï¼Œè®©ç²’å­ä½ç½®äº§ç”ŸæŠ–åŠ¨ï¼Œæ¨¡æ‹Ÿæ°”ä½“æ¹æµ
            float chaosThreshold = 25.0; 
            if (dist < chaosThreshold && dist > 0.1) {
                float chaosIntensity = 1.0 - (dist / chaosThreshold);
                chaosIntensity = pow(chaosIntensity, 3.0);

                float highFreqTime = uTime * 40.0; 
                float noiseX = sin(highFreqTime + pos.x * 10.0) * hash(pos.y);
                float noiseY = cos(highFreqTime + pos.y * 10.0) * hash(pos.x);
                float noiseZ = sin(highFreqTime * 0.5) * hash(pos.z);
                
                vec3 noiseVec = vec3(noiseX, noiseY, noiseZ) * chaosIntensity * 3.0;
                mvPosition.xyz += noiseVec;
            }
            
            gl_Position = projectionMatrix * mvPosition;
            
            // æ ¹æ®è·ç¦»è®¡ç®—ç²’å­å¤§å° (é€è§†æŠ•å½±)
            float pointSize = size * (350.0 / dist); 
            pointSize *= 0.55; 

            // è¿‘è·ç¦»è§‚å¯Ÿè¡Œæ˜Ÿæœ¬ä½“æ—¶ï¼Œç¨å¾®æŠŠç‚¹å˜å°ä¸€ç‚¹ï¼Œçœ‹èµ·æ¥æ›´ç»†è…»
            if (isRing < 0.5 && dist < 50.0) {
                 pointSize *= 0.8; 
            }

            gl_PointSize = clamp(pointSize, 0.0, 300.0);

            // ä¼ é€’æ•°æ®ç»™ç‰‡å…ƒç€è‰²å™¨
            vColor = customColor;
            vOpacity = opacityAttr;
            vScaleFactor = uScale;
            vIsRing = isRing;
        }
    </script>

    <script type="x-shader/x-fragment" id="fragmentshader">
        varying vec3 vColor;
        varying float vDist;
        varying float vOpacity;
        varying float vScaleFactor;
        varying float vIsRing;
        
        void main() {
            // æŠŠæ–¹å½¢çš„ç‚¹å˜æˆåœ†çš„
            vec2 cxy = 2.0 * gl_PointCoord - 1.0;
            float r = dot(cxy, cxy);
            if (r > 1.0) discard;
            
            // è¾¹ç¼˜ç¾½åŒ–ï¼Œåšæˆå…‰çƒçš„æ•ˆæœ
            float glow = smoothstep(1.0, 0.4, r); 
            
            // æ ¹æ®ç¼©æ”¾æ¯”ä¾‹è®¡ç®—ä¸€ä¸ªè¿‡æ¸¡å€¼
            float t = clamp((vScaleFactor - 0.15) / 2.35, 0.0, 1.0);

            // é¢œè‰²æ··åˆé€»è¾‘ï¼šæ”¾å¤§æ—¶åå‘åŸè‰²ï¼Œç¼©å°æ—¶åå‘æ·±é‡‘è‰²
            vec3 deepGold = vec3(0.35, 0.22, 0.05); 
            float colorMix = smoothstep(0.1, 0.9, t);
            vec3 baseColor = mix(deepGold, vColor, colorMix);

            float brightness = 0.2 + 1.0 * t; 

            // å¯†åº¦é€æ˜åº¦è°ƒæ•´
            float densityAlpha = 0.25 + 0.45 * smoothstep(0.0, 0.5, t);

            vec3 finalColor = baseColor * brightness;
            
            // --- è¿‘è·ç¦»çº¹ç†å¢å¼º ---
            if (vDist < 40.0) {
                float closeMix = 1.0 - (vDist / 40.0);
                
                if (vIsRing < 0.5) {
                    // è¡Œæ˜Ÿæœ¬ä½“ï¼šå¢åŠ ä¸€ç‚¹å¯¹æ¯”åº¦å’Œæ·±è‰²çº¹ç†
                    vec3 deepTexture = pow(vColor, vec3(1.4)) * 1.5; 
                    finalColor = mix(finalColor, deepTexture, closeMix * 0.8);
                } else {
                    // å…‰ç¯ï¼šå¢åŠ ä¸€ç‚¹å°˜åŸƒæ„Ÿ
                    finalColor += vec3(0.15, 0.12, 0.1) * closeMix;
                }
            }

            // é˜²æ­¢è¿‘è£åˆ‡é¢å¤ªç”Ÿç¡¬ï¼Œæ·¡å‡º
            float depthAlpha = 1.0;
            if (vDist < 10.0) depthAlpha = smoothstep(0.0, 10.0, vDist);

            float alpha = glow * vOpacity * densityAlpha * depthAlpha;
            
            gl_FragColor = vec4(finalColor, alpha);
        }
    </script>

    <!-- èƒŒæ™¯æ˜Ÿç©ºç€è‰²å™¨ä¿æŒä¸å˜ -->
    <script type="x-shader/x-vertex" id="starVertexShader">
        attribute float size;
        attribute vec3 customColor;
        varying vec3 vColor;
        uniform float uTime;

        void main() {
            vColor = customColor;
            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
            float dist = -mvPosition.z;
            // æ˜Ÿæ˜Ÿä¸éœ€è¦å¤ªå¤§ï¼Œè¿™é‡Œé™åˆ¶ä¸€ä¸‹å¤§å°
            gl_PointSize = size * (1000.0 / dist); 
            gl_PointSize = clamp(gl_PointSize, 1.0, 8.0);
            gl_Position = projectionMatrix * mvPosition;
        }
    </script>

    <script type="x-shader/x-fragment" id="starFragmentShader">
        varying vec3 vColor;
        uniform float uTime;
        float random(vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123); }
        void main() {
            vec2 cxy = 2.0 * gl_PointCoord - 1.0;
            float r = dot(cxy, cxy);
            if (r > 1.0) discard;
            
            // æ¨¡æ‹Ÿæ˜Ÿæ˜Ÿé—ªçƒ
            float noise = random(gl_FragCoord.xy);
            float twinkle = 0.7 + 0.3 * sin(uTime * 2.0 + noise * 10.0);
            
            float glow = 1.0 - r;
            glow = pow(glow, 1.5);
            
            gl_FragColor = vec4(vColor * twinkle, glow * 0.8);
        }
    </script>

    <!-- è¡Œæ˜Ÿç€è‰²å™¨ä¿æŒä¸å˜ -->
    <script type="x-shader/x-vertex" id="planetVertexShader">
        varying vec2 vUv;
        varying vec3 vNormal;
        varying vec3 vViewPosition;
        void main() {
            vUv = uv;
            vNormal = normalize(normalMatrix * normal);
            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
            vViewPosition = -mvPosition.xyz;
            gl_Position = projectionMatrix * mvPosition;
        }
    </script>

    <script type="x-shader/x-fragment" id="planetFragmentShader">
        uniform vec3 color1;
        uniform vec3 color2;
        uniform float noiseScale;
        uniform vec3 lightDir;
        uniform float atmosphere;
        
        varying vec2 vUv;
        varying vec3 vNormal;
        varying vec3 vViewPosition;

        // åŸºç¡€å™ªå£°å‡½æ•°
        float random(vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123); }
        float noise(vec2 st) {
            vec2 i = floor(st);
            vec2 f = fract(st);
            float a = random(i);
            float b = random(i + vec2(1.0, 0.0));
            float c = random(i + vec2(0.0, 1.0));
            float d = random(i + vec2(1.0, 1.0));
            vec2 u = f * f * (3.0 - 2.0 * f);
            return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
        }
        
        // åˆ†å½¢å¸ƒæœ—è¿åŠ¨ (FBM) - ç”¨æ¥ç”Ÿæˆåœ°å½¢æˆ–äº‘å±‚çº¹ç†
        float fbm(vec2 st) {
            float value = 0.0;
            float amplitude = 0.5;
            for (int i = 0; i < 5; i++) {
                value += amplitude * noise(st);
                st *= 2.0;
                amplitude *= 0.5;
            }
            return value;
        }

        void main() {
            // æ ¹æ®å™ªå£°ç”Ÿæˆåœ°è¡¨é¢œè‰²
            float n = fbm(vUv * noiseScale);
            vec3 albedo = mix(color1, color2, n);
            
            // ç®€å•çš„æ¼«åå°„å…‰ç…§
            vec3 normal = normalize(vNormal);
            vec3 light = normalize(lightDir);
            float diff = max(dot(normal, light), 0.05);
            
            // è²æ¶…å°”æ•ˆåº” (Fresnel) - ç”¨æ¥æ¨¡æ‹Ÿå¤§æ°”å±‚è¾¹ç¼˜å‘å…‰
            vec3 viewDir = normalize(vViewPosition);
            float fresnel = pow(1.0 - dot(viewDir, normal), 3.0);
            
            vec3 finalColor = albedo * diff + atmosphere * vec3(0.5, 0.6, 1.0) * fresnel;
            
            gl_FragColor = vec4(finalColor, 1.0);
        }
    </script>

    <script>
        // å…¨å±€å˜é‡
        let scene, camera, renderer, particles, stars, nebula;
        let planetGroup;
        let uniforms, starUniforms;
        
        // ç›®æ ‡å€¼ vs å½“å‰å€¼ (ç”¨äºå¹³æ»‘åŠ¨ç”»)
        let targetScale = 1.0;
        let targetRotX = 0.4;
        let currentScale = 1.0;
        let currentRotX = 0.4;
        
        // æ€§èƒ½ç›¸å…³å˜é‡
        let particleCount = 600000; // é»˜è®¤ç²’å­æ•°
        let performanceMode = 'medium'; // æ€§èƒ½æ¨¡å¼
        let isUIHidden = false;
        let isHandDetected = false;
        let lastHandDetectionTime = 0;
        let handTrackingEnabled = false;
        
        // DOM å…ƒç´ 
        const videoElement = document.getElementsByClassName('input_video')[0];
        const statusElement = document.getElementById('status-indicator');
        const loadingElement = document.getElementById('loading');
        const fpsCounter = document.getElementById('fps-counter');
        const particleCountElement = document.getElementById('particle-count');
        const performanceModeElement = document.getElementById('performance-mode');
        const infoPanel = document.getElementById('info-panel');
        const gestureGuide = document.getElementById('gesture-guide');
        const cameraPermissionPanel = document.getElementById('camera-permission');
        const toggleHandTrackingBtn = document.getElementById('toggle-hand-tracking');
        
        // æ€§èƒ½ç›‘æ§
        let frameCount = 0;
        let lastTime = performance.now();
        let fps = 0;
        
        // æ‰‹åŠ¿è¯†åˆ«ç›¸å…³å˜é‡
        let hands;
        let cameraUtils;

        // åˆå§‹åŒ–Three.jsåœºæ™¯
        function initThree() {
            const container = document.getElementById('canvas-container');

            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x020202, 0.00015);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 10000);
            camera.position.z = 100;
            camera.lookAt(0, 0, 0);

            // åˆå§‹åŒ–åœŸæ˜Ÿç³»ç»Ÿ
            initSaturn();
            
            // åˆå§‹åŒ–èƒŒæ™¯æ˜Ÿç©º
            initStarfield();

            // åˆå§‹åŒ–èƒŒæ™¯å®ä½“è¡Œæ˜Ÿ
            initPlanets();

            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setClearColor(0x000000, 0); 
            container.appendChild(renderer.domElement);

            window.addEventListener('resize', onWindowResize);

            // æ€§èƒ½æ¨¡å¼é€‰æ‹©äº‹ä»¶
            document.querySelectorAll('input[name="performance"]').forEach(radio => {
                radio.addEventListener('change', function() {
                    setPerformanceMode(this.value);
                });
            });

            // å¼€å§‹æ¸²æŸ“å¾ªç¯
            animate();
            
            // æ›´æ–°çŠ¶æ€æŒ‡ç¤ºå™¨
            updateStatusIndicator("è‡ªåŠ¨å·¡èˆª", "ç­‰å¾…ä¸­...", "#666");
            
            // åˆå§‹åŒ–æ‰‹åŠ¿è¯†åˆ«ï¼ˆä½†ä¸ç«‹å³å¯åŠ¨ï¼‰
            initHandTracking();
        }

        // åˆå§‹åŒ–æ‰‹åŠ¿è¯†åˆ«ç³»ç»Ÿ
        function initHandTracking() {
            hands = new Hands({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                }
            });

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.6
            });

            hands.onResults(onResults);
            
            // åˆ›å»ºæ‘„åƒå¤´å·¥å…·ä½†ä¸ç«‹å³å¯åŠ¨
            cameraUtils = new Camera(videoElement, {
                onFrame: async () => {
                    if (handTrackingEnabled) {
                        try {
                            await hands.send({image: videoElement});
                        } catch (e) {
                            console.error("æ‰‹åŠ¿è¯†åˆ«é”™è¯¯:", e);
                        }
                    }
                },
                width: 640,
                height: 480
            });
        }

        // æ‰‹åŠ¿è¯†åˆ«ç»“æœå¤„ç†
        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                isHandDetected = true;
                lastHandDetectionTime = performance.now() / 1000;
                const hand = results.multiHandLandmarks[0];

                // ç”¨å¤§æ‹‡æŒ‡å’Œé£ŸæŒ‡çš„è·ç¦»æ§åˆ¶ç¼©æ”¾
                const p1 = hand[4];
                const p2 = hand[8];
                const dist = Math.sqrt((p1.x-p2.x)**2 + (p1.y-p2.y)**2);
                
                // å½’ä¸€åŒ–è·ç¦»å¹¶æ˜ å°„åˆ°ç¼©æ”¾ç³»æ•°
                const normDist = Math.max(0, Math.min(1, (dist - 0.02) / 0.25));
                targetScale = 0.15 + normDist * 2.35; 

                // ç”¨æ‰‹æŒåœ¨å±å¹•çš„ Y è½´ä½ç½®æ§åˆ¶ä¿¯ä»°è§’
                const y = hand[9].y;
                const normY = Math.max(0, Math.min(1, (y - 0.1) / 0.8));
                targetRotX = -0.6 + normY * 1.6;

                // æ›´æ–°çŠ¶æ€æŒ‡ç¤ºå™¨
                updateStatusIndicator("æ‰‹åŠ¨æ§åˆ¶", "å·²è¿æ¥", "#c5a059");
                
                // éšè—æ‰‹åŠ¿å¼•å¯¼
                hideGestureGuide();
            } else {
                isHandDetected = false;
                // å¦‚æœè¶…è¿‡5ç§’æ²¡æœ‰æ£€æµ‹åˆ°æ‰‹ï¼Œæ˜¾ç¤ºæç¤º
                if (performance.now() / 1000 - lastHandDetectionTime > 5) {
                    updateStatusIndicator("æ‰‹åŠ¨æ§åˆ¶", "ç­‰å¾…æ‰‹åŠ¿...", "#c5a059");
                    showGestureGuide();
                }
            }
        }

        // è¯·æ±‚æ‘„åƒå¤´æƒé™
        function requestCameraPermission() {
            cameraUtils.start().then(() => {
                // æ‘„åƒå¤´å¯åŠ¨æˆåŠŸ
                cameraPermissionPanel.classList.add('hidden');
                handTrackingEnabled = true;
                toggleHandTrackingBtn.textContent = 'å…³é—­æ‰‹åŠ¿æ§åˆ¶';
                toggleHandTrackingBtn.classList.add('active');
                updateStatusIndicator("æ‰‹åŠ¨æ§åˆ¶", "ç­‰å¾…æ‰‹åŠ¿...", "#c5a059");
                showGestureGuide();
            }).catch(e => {
                console.error("æ‘„åƒå¤´å¯åŠ¨å¤±è´¥:", e);
                alert("æ— æ³•è®¿é—®æ‘„åƒå¤´ï¼Œè¯·æ£€æŸ¥æƒé™è®¾ç½®æˆ–ä½¿ç”¨è‡ªåŠ¨æ¼”ç¤ºæ¨¡å¼");
                skipCameraPermission();
            });
        }

        // è·³è¿‡æ‘„åƒå¤´æƒé™
        function skipCameraPermission() {
            cameraPermissionPanel.classList.add('hidden');
            handTrackingEnabled = false;
            toggleHandTrackingBtn.textContent = 'å¼€å¯æ‰‹åŠ¿æ§åˆ¶';
            toggleHandTrackingBtn.classList.remove('active');
            updateStatusIndicator("è‡ªåŠ¨å·¡èˆª", "ç­‰å¾…ä¸­...", "#666");
        }

        // åˆ‡æ¢æ‰‹åŠ¿æ§åˆ¶
        function toggleHandTracking() {
            if (handTrackingEnabled) {
                // å…³é—­æ‰‹åŠ¿æ§åˆ¶
                handTrackingEnabled = false;
                toggleHandTrackingBtn.textContent = 'å¼€å¯æ‰‹åŠ¿æ§åˆ¶';
                toggleHandTrackingBtn.classList.remove('active');
                updateStatusIndicator("è‡ªåŠ¨å·¡èˆª", "ç­‰å¾…ä¸­...", "#666");
                hideGestureGuide();
            } else {
                // å¼€å¯æ‰‹åŠ¿æ§åˆ¶
                cameraPermissionPanel.classList.remove('hidden');
            }
        }

        // åˆå§‹åŒ–åœŸæ˜Ÿç³»ç»Ÿ
        function initSaturn() {
            // æ ¹æ®æ€§èƒ½æ¨¡å¼è®¾ç½®ç²’å­æ•°é‡
            switch(performanceMode) {
                case 'low': particleCount = 300000; break;
                case 'medium': particleCount = 600000; break;
                case 'high': particleCount = 900000; break;
            }
            
            particleCountElement.textContent = `${Math.round(particleCount/10000)/10}ä¸‡+`;
            performanceModeElement.textContent = 
                performanceMode === 'low' ? 'èŠ‚èƒ½' : 
                performanceMode === 'medium' ? 'å¹³è¡¡' : 'æè‡´';

            const geometry = new THREE.BufferGeometry();
            
            // ç”³è¯·å†…å­˜
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);
            const opacities = new Float32Array(particleCount);
            const orbitSpeeds = new Float32Array(particleCount);
            const isRings = new Float32Array(particleCount);
            const randomIds = new Float32Array(particleCount);

            // åœŸæ˜Ÿæœ¬ä½“çš„è‰²è°ƒ
            const bodyColors = [
                new THREE.Color('#E3DAC5'), 
                new THREE.Color('#C9A070'), 
                new THREE.Color('#E3DAC5'), 
                new THREE.Color('#B08D55')  
            ];
            
            // åœŸæ˜Ÿç¯çš„å„å±‚é¢œè‰²
            const colorRingC = new THREE.Color('#2A2520'); 
            const colorRingB_Inner = new THREE.Color('#CDBFA0'); 
            const colorRingB_Outer = new THREE.Color('#DCCBBA'); 
            const colorCassini = new THREE.Color('#050505');
            const colorRingA = new THREE.Color('#989085'); 
            const colorRingF = new THREE.Color('#AFAFA0'); 

            const R_PLANET = 18; // è¡Œæ˜ŸåŸºç¡€åŠå¾„

            for(let i = 0; i < particleCount; i++) {
                let x, y, z, r, g, b, size, opacity, speed, isRingVal;
                randomIds[i] = Math.random();

                // å‰ 25% çš„ç²’å­ç”¨æ¥ç”»åœŸæ˜Ÿæœ¬ä½“
                if (i < particleCount * 0.25) {
                    isRingVal = 0.0;
                    speed = 0.0;
                    const u = Math.random();
                    const v = Math.random();
                    const theta = 2 * Math.PI * u;
                    const phi = Math.acos(2 * v - 1);
                    const rad = R_PLANET;
                    
                    x = rad * Math.sin(phi) * Math.cos(theta);
                    let rawY = rad * Math.cos(phi);
                    z = rad * Math.sin(phi) * Math.sin(theta);
                    
                    // åœŸæ˜Ÿæ˜¯æ‰çš„ï¼Œå‹æ‰ä¸€ç‚¹ Y è½´
                    y = rawY * 0.9;
                    
                    // ç”Ÿæˆæ¡çº¹å›¾æ¡ˆ
                    let lat = (rawY / rad + 1.0) * 0.5; 
                    let bandNoise = Math.cos(lat * 40.0) * 0.8 + Math.cos(lat * 15.0) * 0.4;
                    let colIndex = Math.floor(lat * 4 + bandNoise) % 4;
                    if (colIndex < 0) colIndex = 0;
                    let baseCol = bodyColors[colIndex];
                    
                    r = baseCol.r; g = baseCol.g; b = baseCol.b;
                    size = 1.0 + Math.random() * 0.8; 
                    opacity = 0.8; 
                } else {
                    // å‰©ä¸‹çš„ç²’å­ç”»å…‰ç¯
                    isRingVal = 1.0;
                    let zoneRand = Math.random();
                    let ringRadius;
                    let ringCol;
                    
                    // æ ¹æ®æ¦‚ç‡åˆ†å¸ƒç”Ÿæˆä¸åŒçš„ç¯å¸¦
                    if (zoneRand < 0.15) { 
                        // Cç¯
                        ringRadius = R_PLANET * (1.235 + Math.random() * (1.525 - 1.235));
                        ringCol = colorRingC;
                        size = 0.5; opacity = 0.3; 
                    } else if (zoneRand < 0.65) { 
                        // Bç¯
                        let t = Math.random();
                        ringRadius = R_PLANET * (1.525 + t * (1.95 - 1.525));
                        ringCol = colorRingB_Inner.clone().lerp(colorRingB_Outer, t);
                        size = 0.8 + Math.random() * 0.6; opacity = 0.85; 
                        if (Math.sin(ringRadius * 2.0) > 0.8) opacity *= 1.2;
                    } else if (zoneRand < 0.69) { 
                        // å¡è¥¿å°¼ç¼
                        ringRadius = R_PLANET * (1.95 + Math.random() * (2.025 - 1.95));
                        ringCol = colorCassini;
                        size = 0.3; opacity = 0.1; 
                    } else if (zoneRand < 0.99) { 
                        // Aç¯
                        ringRadius = R_PLANET * (2.025 + Math.random() * (2.27 - 2.025));
                        ringCol = colorRingA;
                        size = 0.7; opacity = 0.6;
                        if (ringRadius > R_PLANET * 2.2 && ringRadius < R_PLANET * 2.21) opacity = 0.1;
                    } else { 
                        // Fç¯
                        ringRadius = R_PLANET * (2.32 + Math.random() * 0.02);
                        ringCol = colorRingF;
                        size = 1.0; opacity = 0.7;
                    }
                    
                    const theta = Math.random() * Math.PI * 2;
                    x = ringRadius * Math.cos(theta);
                    z = ringRadius * Math.sin(theta);
                    
                    // ç¯ä¹Ÿæ˜¯æœ‰åšåº¦çš„ï¼Œç¨å¾®éšæœºä¸€ç‚¹ Y
                    let thickness = 0.15;
                    if (ringRadius > R_PLANET * 2.3) thickness = 0.4; 
                    y = (Math.random() - 0.5) * thickness;
                    
                    r = ringCol.r; g = ringCol.g; b = ringCol.b;
                    
                    // å¼€æ™®å‹’ç¬¬ä¸‰å®šå¾‹ï¼šè¶Šå¤–å±‚è½¬å¾—è¶Šæ…¢
                    speed = 8.0 / Math.sqrt(ringRadius);
                }
                
                positions[i*3] = x; positions[i*3+1] = y; positions[i*3+2] = z;
                colors[i*3] = r; colors[i*3+1] = g; colors[i*3+2] = b;
                sizes[i] = size; opacities[i] = opacity;
                orbitSpeeds[i] = speed; isRings[i] = isRingVal;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('customColor', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            geometry.setAttribute('opacityAttr', new THREE.BufferAttribute(opacities, 1));
            geometry.setAttribute('orbitSpeed', new THREE.BufferAttribute(orbitSpeeds, 1));
            geometry.setAttribute('isRing', new THREE.BufferAttribute(isRings, 1));
            geometry.setAttribute('aRandomId', new THREE.BufferAttribute(randomIds, 1));

            uniforms = {
                uTime: { value: 0 },
                uScale: { value: 1.0 },
                uRotationX: { value: 0.4 }
            };

            const material = new THREE.ShaderMaterial({
                depthWrite: false,
                blending: THREE.AdditiveBlending,
                vertexColors: true,
                uniforms: uniforms,
                vertexShader: document.getElementById('vertexshader').textContent,
                fragmentShader: document.getElementById('fragmentshader').textContent,
                transparent: true
            });

            particles = new THREE.Points(geometry, material);
            particles.rotation.z = 26.73 * (Math.PI / 180); // åœŸæ˜ŸçœŸå®çš„è½´å€¾è§’
            scene.add(particles);
        }

        // åˆå§‹åŒ–èƒŒæ™¯æ˜Ÿç©º
        function initStarfield() {
            const starCount = performanceMode === 'low' ? 20000 : 
                             performanceMode === 'medium' ? 50000 : 80000;
            
            const geo = new THREE.BufferGeometry();
            const pos = new Float32Array(starCount * 3);
            const cols = new Float32Array(starCount * 3);
            const sizes = new Float32Array(starCount);
            
            // æ˜Ÿæ˜Ÿé¢œè‰²ç±»å‹
            const starColors = [
                new THREE.Color('#9bb0ff'), new THREE.Color('#ffffff'), 
                new THREE.Color('#ffcc6f'), new THREE.Color('#ff7b7b')
            ];

            for(let i=0; i<starCount; i++) {
                const r = 400 + Math.random() * 3000;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                
                pos[i*3] = r * Math.sin(phi) * Math.cos(theta);
                pos[i*3+1] = r * Math.cos(phi);
                pos[i*3+2] = r * Math.sin(phi) * Math.sin(theta);
                
                const colorType = Math.random();
                let c;
                if(colorType > 0.9) c = starColors[0]; else if(colorType > 0.6) c = starColors[1];
                else if(colorType > 0.3) c = starColors[2]; else c = starColors[3];
                
                cols[i*3] = c.r; cols[i*3+1] = c.g; cols[i*3+2] = c.b;
                sizes[i] = 1.0 + Math.random() * 3.0;
            }
            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            geo.setAttribute('customColor', new THREE.BufferAttribute(cols, 3));
            geo.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            starUniforms = { uTime: { value: 0 } };
            const mat = new THREE.ShaderMaterial({
                uniforms: starUniforms,
                vertexShader: document.getElementById('starVertexShader').textContent,
                fragmentShader: document.getElementById('starFragmentShader').textContent,
                transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
            });
            stars = new THREE.Points(geo, mat);
            scene.add(stars);

            // æ˜Ÿäº‘æ•ˆæœ
            const nebulaCount = performanceMode === 'low' ? 50 : 100;
            const nebGeo = new THREE.BufferGeometry();
            const nebPos = new Float32Array(nebulaCount * 3);
            const nebCols = new Float32Array(nebulaCount * 3);
            const nebSizes = new Float32Array(nebulaCount);
            for(let i=0; i<nebulaCount; i++) {
                const r = 800 + Math.random() * 2000;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.PI / 2 + (Math.random() - 0.5) * 1.5;
                nebPos[i*3] = r * Math.sin(phi) * Math.cos(theta);
                nebPos[i*3+1] = r * Math.cos(phi);
                nebPos[i*3+2] = r * Math.sin(phi) * Math.sin(theta);
                const nc = new THREE.Color().setHSL(0.6 + Math.random()*0.2, 0.8, 0.05);
                nebCols[i*3] = nc.r; nebCols[i*3+1] = nc.g; nebCols[i*3+2] = nc.b;
                nebSizes[i] = 400.0 + Math.random() * 600.0;
            }
            nebGeo.setAttribute('position', new THREE.BufferAttribute(nebPos, 3));
            nebGeo.setAttribute('customColor', new THREE.BufferAttribute(nebCols, 3));
            nebGeo.setAttribute('size', new THREE.BufferAttribute(nebSizes, 1));
            const nebShaderMat = new THREE.ShaderMaterial({
                uniforms: {},
                vertexShader: document.getElementById('starVertexShader').textContent,
                fragmentShader: `
                    varying vec3 vColor;
                    void main() {
                        vec2 cxy = 2.0 * gl_PointCoord - 1.0;
                        float r = dot(cxy, cxy);
                        if(r > 1.0) discard;
                        float glow = pow(1.0 - r, 2.0);
                        gl_FragColor = vec4(vColor, glow * 0.1); 
                    }
                `,
                transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
            });
            nebula = new THREE.Points(nebGeo, nebShaderMat);
            scene.add(nebula);
        }

        // åˆå§‹åŒ–èƒŒæ™¯å®ä½“è¡Œæ˜Ÿ
        function initPlanets() {
            planetGroup = new THREE.Group();
            scene.add(planetGroup);

            const vShader = document.getElementById('planetVertexShader').textContent;
            const fShader = document.getElementById('planetFragmentShader').textContent;

            // 1. ç«æ˜Ÿ (Mars) - çº¢è‰²ï¼Œå™ªç‚¹å¤š
            createPlanet(planetGroup, vShader, fShader, 
                new THREE.Color('#b33a00'), new THREE.Color('#d16830'), 8.0, 
                { x: -300, y: 120, z: -450 }, 10, 0.3 
            );

            // 2. åœ°çƒ (Earth) - è“ç™½ç›¸é—´
            createPlanet(planetGroup, vShader, fShader, 
                new THREE.Color('#001e4d'), new THREE.Color('#ffffff'), 5.0, 
                { x: 380, y: -100, z: -600 }, 14, 0.6 
            );

            // 3. æ°´æ˜Ÿ (Mercury) - ç°ç™½ï¼Œå°
            createPlanet(planetGroup, vShader, fShader, 
                new THREE.Color('#666666'), new THREE.Color('#aaaaaa'), 15.0, 
                { x: -180, y: -220, z: -350 }, 6, 0.1 
            );
        }

        // åˆ›å»ºè¡Œæ˜Ÿå‡½æ•°
        function createPlanet(group, vShader, fShader, c1, c2, nScale, pos, radius, atmo) {
            const geo = new THREE.SphereGeometry(radius, 48, 48);
            const mat = new THREE.ShaderMaterial({
                uniforms: {
                    color1: { value: c1 },
                    color2: { value: c2 },
                    noiseScale: { value: nScale },
                    lightDir: { value: new THREE.Vector3(1, 0.5, 1) },
                    atmosphere: { value: atmo }
                },
                vertexShader: vShader,
                fragmentShader: fShader
            });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(pos.x, pos.y, pos.z);
            group.add(mesh);
        }

        const clock = new THREE.Clock();
        let autoIdleTime = 0;

        // åŠ¨ç”»å¾ªç¯
        function animate() {
            requestAnimationFrame(animate);

            const elapsedTime = clock.getElapsedTime();
            uniforms.uTime.value = elapsedTime;
            if(starUniforms) starUniforms.uTime.value = elapsedTime;

            // ç¼“æ…¢æ—‹è½¬èƒŒæ™¯æ˜Ÿç©º
            if(stars) stars.rotation.y = elapsedTime * 0.005;
            if(nebula) nebula.rotation.y = elapsedTime * 0.003;
            
            // è¡Œæ˜Ÿè‡ªè½¬
            if(planetGroup) {
                planetGroup.children.forEach((planet, idx) => {
                    planet.rotation.y = elapsedTime * (0.05 + idx * 0.02);
                });
                planetGroup.rotation.y = Math.sin(elapsedTime * 0.05) * 0.02;
            }

            // è‡ªåŠ¨å·¡èˆªæ¨¡å¼
            if (!handTrackingEnabled || !isHandDetected) {
                autoIdleTime += 0.005;
                targetScale = 1.0 + Math.sin(autoIdleTime) * 0.2;
                targetRotX = 0.4 + Math.sin(autoIdleTime * 0.3) * 0.15;
                
                if (!handTrackingEnabled) {
                    updateStatusIndicator("è‡ªåŠ¨å·¡èˆª", "ç­‰å¾…ä¸­...", "#666");
                }
                
                // æ˜¾ç¤ºæç¤ºä¿¡æ¯
                if (elapsedTime - lastHandDetectionTime > 5 && handTrackingEnabled) {
                    showInfoPanel();
                }
            }

            // å¹³æ»‘æ’å€¼
            const lerpFactor = 0.08;
            currentScale += (targetScale - currentScale) * lerpFactor;
            currentRotX += (targetRotX - currentRotX) * lerpFactor;

            uniforms.uScale.value = currentScale;
            uniforms.uRotationX.value = currentRotX;

            renderer.render(scene, camera);
            
            // æ›´æ–°FPSè®¡æ•°å™¨
            updateFPS();
            
            // éšè—åŠ è½½ç•Œé¢
            if (elapsedTime > 1) {
                loadingElement.style.opacity = '0';
                if (elapsedTime > 1.5) {
                    loadingElement.style.display = 'none';
                }
            }
        }

        // è¾…åŠ©å‡½æ•°
        function toggleFullScreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else if (document.exitFullscreen) {
                document.exitFullscreen();
            }
        }
        
        function toggleUI() {
            isUIHidden = !isUIHidden;
            const uiLayer = document.getElementById('ui-layer');
            const performancePanel = document.getElementById('performance-panel');
            const toggleBtn = document.getElementById('toggle-ui');
            
            if (isUIHidden) {
                uiLayer.style.opacity = '0';
                performancePanel.style.opacity = '0';
                toggleBtn.textContent = 'æ˜¾ç¤ºç•Œé¢';
                toggleBtn.classList.add('active');
            } else {
                uiLayer.style.opacity = '1';
                performancePanel.style.opacity = '1';
                toggleBtn.textContent = 'éšè—ç•Œé¢';
                toggleBtn.classList.remove('active');
            }
        }
        
        function resetView() {
            targetScale = 1.0;
            targetRotX = 0.4;
            
            // æ·»åŠ æŒ‰é’®åé¦ˆ
            const btn = document.getElementById('reset-view');
            btn.classList.add('active');
            setTimeout(() => {
                btn.classList.remove('active');
            }, 300);
        }
        
        function setPerformanceMode(mode) {
            performanceMode = mode;
            
            // é‡æ–°åˆå§‹åŒ–åœºæ™¯
            if (scene) {
                // ç§»é™¤ç°æœ‰å¯¹è±¡
                if (particles) scene.remove(particles);
                if (stars) scene.remove(stars);
                if (nebula) scene.remove(nebula);
                
                // é‡æ–°åˆå§‹åŒ–
                initSaturn();
                initStarfield();
            }
        }
        
        function hideGestureGuide() {
            gestureGuide.classList.add('hidden');
        }
        
        function showGestureGuide() {
            gestureGuide.classList.remove('hidden');
        }
        
        function showInfoPanel() {
            infoPanel.classList.add('visible');
            setTimeout(() => {
                infoPanel.classList.remove('visible');
            }, 3000);
        }
        
        function updateFPS() {
            frameCount++;
            const currentTime = performance.now();
            if (currentTime >= lastTime + 1000) {
                fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
                frameCount = 0;
                lastTime = currentTime;
                
                fpsCounter.textContent = `FPS: ${fps} | ç²’å­æ•°: ${Math.round(particleCount/10000)/10}ä¸‡`;
            }
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function updateStatusIndicator(status, signal, color) {
            statusElement.innerHTML = `ç³»ç»ŸçŠ¶æ€: ${status}<br>è¾“å…¥ä¿¡å·: <span class="highlight">${signal}</span>`;
            statusElement.style.color = color;
        }

        // åˆå§‹åŒ–
        window.addEventListener('load', initThree);
    </script>
</body>
</html>
