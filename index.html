<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D粒子打火花系统 - 优化版</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/handpose@0.0.7/dist/handpose.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core@2.7.0/dist/tf-core.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter@2.7.0/dist/tf-converter.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl@2.7.0/dist/tf-backend-webgl.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #000; color: #fff; }
        #canvas-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        #ui { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 2; pointer-events: none; }
        .ui-element {
            pointer-events: auto;
            position: absolute;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 215, 0, 0.6);
            border-radius: 8px;
            padding: 12px 20px;
            color: #ffd700;
            backdrop-filter: blur(4px);
            transition: all 0.3s;
        }
        .ui-element:hover { background: rgba(30, 30, 30, 0.8); border-color: #ffd700; }
        #title { top: 20px; left: 20px; font-size: 1.5rem; font-weight: bold; }
        #controls { top: 20px; right: 20px; display: flex; gap: 10px; }
        button {
            background: rgba(255, 69, 0, 0.7);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 8px 16px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }
        button:hover { background: rgba(255, 69, 0, 0.9); transform: translateY(-2px); }
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(255, 215, 0, 0.3);
            border-top: 5px solid #ffd700;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .hidden { display: none !important; }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="ui">
        <div id="title" class="ui-element">3D粒子打火花系统</div>
        <div id="controls" class="ui-element">
            <button id="fullscreen-btn">全屏</button>
            <button id="reset-btn">重置粒子</button>
        </div>
    </div>
    <div id="loading">
        <div class="spinner"></div>
        <div>正在初始化...</div>
    </div>

    <script>
        // 全局变量
        let scene, camera, renderer, composer;
        let particles = [];
        let handposeModel = null;
        let video = null;
        let handScale = 1.0;
        let lastHandScale = 1.0;
        let isFullscreen = false;
        let bloomPass;
        
        // 优化后的参数
        const params = {
            particleCount: 3000,
            baseSize: 0.04,
            baseBrightness: 1.0,
            maxSpeed: 0.6,
            maxOrbitRadius: 8,
            bloomStrength: 3.0,
            bloomRadius: 1.0,
            bloomThreshold: 0.3,
            colorRange: { h: [0.03, 0.15], s: [0.7, 1.0], v: [0.8, 1.0] }
        };
        
        // 粒子系统
        const particleSystem = {
            particles: [],
            positions: [],
            velocities: [],
            sizes: [],
            brightness: [],
            colors: [],
            orbitParams: [],
            chaosFactor: 0,
            noiseOffset: 0,
            
            init() {
                this.particles = new Array(params.particleCount);
                this.positions = new Array(params.particleCount);
                this.velocities = new Array(params.particleCount);
                this.sizes = new Array(params.particleCount);
                this.brightness = new Array(params.particleCount);
                this.colors = new Array(params.particleCount);
                this.orbitParams = new Array(params.particleCount);
                
                this.chaosFactor = 0;
                this.noiseOffset = 0;
                
                const center = new THREE.Vector3(0, 0, 0);
                
                for (let i = 0; i < params.particleCount; i++) {
                    // 轨道参数
                    const a = 1 + Math.random() * (params.maxOrbitRadius - 1);
                    const e = 0.2 + Math.random() * 0.7;
                    const i = Math.random() * Math.PI;
                    const ω = Math.random() * 2 * Math.PI;
                    const M = Math.random() * 2 * Math.PI;
                    
                    // 计算初始位置
                    const E = this.solveKepler(M, e);
                    const xOrbit = a * (Math.cos(E) - e);
                    const yOrbit = a * Math.sqrt(1 - e * e) * Math.sin(E);
                    
                    // 应用轨道参数
                    const cosω = Math.cos(ω);
                    const sinω = Math.sin(ω);
                    const cosi = Math.cos(i);
                    const sini = Math.sin(i);
                    
                    const x = (cosω * xOrbit - sinω * yOrbit);
                    const z = (sinω * xOrbit + cosω * yOrbit) * cosi;
                    const y = (sinω * xOrbit + cosω * yOrbit) * sini;
                    
                    // 存储轨道参数
                    this.orbitParams[i] = { a, e, i, ω, M };
                    
                    // 初始位置和速度
                    this.positions[i] = new THREE.Vector3(x, y, z);
                    
                    const r = Math.sqrt(x*x + y*y + z*z);
                    const speed = Math.sqrt(2/r - 1/a) * 0.5;
                    
                    const velocityDir = new THREE.Vector3(-z, 0, x).normalize();
                    if (velocityDir.length() === 0) velocityDir.set(1, 0, 0);
                    velocityDir.applyAxisAngle(new THREE.Vector3(1, 0, 0), i);
                    
                    this.velocities[i] = velocityDir.multiplyScalar(speed);
                    
                    // 粒子属性
                    this.sizes[i] = params.baseSize * (0.5 + Math.random() * 1.5);
                    this.brightness[i] = 0.5 + Math.random() * 0.5;
                    
                    // 颜色（优化后的色域）
                    const h = params.colorRange.h[0] + Math.random() * (params.colorRange.h[1] - params.colorRange.h[0]);
                    const s = params.colorRange.s[0] + Math.random() * (params.colorRange.s[1] - params.colorRange.s[0]);
                    const v = params.colorRange.v[0] + Math.random() * (params.colorRange.v[1] - params.colorRange.v[0]);
                    
                    const color = new THREE.Color();
                    color.setHSL(h, s, v);
                    this.colors[i] = color;
                }
            },
            
            solveKepler(M, e, iterations = 5) {
                let E = M;
                for (let i = 0; i < iterations; i++) {
                    E = M + e * Math.sin(E);
                }
                return E;
            },
            
            update(smoothHandScale) {
                const scaleFactor = 0.5 + smoothHandScale * 2.5;
                const chaosFactor = Math.max(0, (scaleFactor - 2) * 2);
                this.chaosFactor = chaosFactor;
                this.noiseOffset += 0.01;
                
                for (let i = 0; i < params.particleCount; i++) {
                    const pos = this.positions[i];
                    const vel = this.velocities[i];
                    const { a } = this.orbitParams[i];
                    
                    // 引力计算
                    const distance = pos.length();
                    const gravityStrength = 0.1 / (distance * distance + 0.01);
                    const gravity = pos.clone().multiplyScalar(-gravityStrength);
                    vel.add(gravity);
                    
                    // 混沌效果
                    if (chaosFactor > 0) {
                        // 布朗运动
                        vel.add(new THREE.Vector3(
                            (Math.random() - 0.5) * 0.02 * chaosFactor,
                            (Math.random() - 0.5) * 0.02 * chaosFactor,
                            (Math.random() - 0.5) * 0.02 * chaosFactor
                        ));
                        
                        // 噪点运动
                        vel.x += Math.sin(i + this.noiseOffset * 10) * 0.01 * chaosFactor;
                        vel.y += Math.cos(i * 2 + this.noiseOffset * 8) * 0.01 * chaosFactor;
                        vel.z += Math.sin(i * 3 + this.noiseOffset * 12) * 0.01 * chaosFactor;
                    }
                    
                    // 速度限制
                    if (vel.length() > params.maxSpeed) {
                        vel.normalize().multiplyScalar(params.maxSpeed);
                    }
                    
                    // 更新位置
                    pos.add(vel);
                    
                    // 屏幕空间位置
                    const screenPos = pos.clone().multiplyScalar(scaleFactor).project(camera);
                    
                    // 粒子属性
                    let particleSize = this.sizes[i] * scaleFactor;
                    let brightness = this.brightness[i] * Math.pow(scaleFactor, 2);
                    
                    // 屏幕边缘效果
                    const screenEdgeFactor = Math.max(Math.abs(screenPos.x), Math.abs(screenPos.y));
                    if (screenEdgeFactor > 0.8) {
                        const edgeFactor = (screenEdgeFactor - 0.8) * 5;
                        vel.x += (Math.random() - 0.5) * 0.1 * edgeFactor;
                        vel.y += (Math.random() - 0.5) * 0.1 * edgeFactor;
                        vel.z += (Math.random() - 0.5) * 0.1 * edgeFactor;
                        brightness *= 1 + Math.sin(Date.now() * 0.01 + i) * 0.5;
                    }
                    
                    // 炸开效果
                    if (scaleFactor > 2.5) {
                        const explodeFactor = (scaleFactor - 2.5) * 2;
                        vel.add(pos.clone().normalize().multiplyScalar(0.05 * explodeFactor));
                        particleSize *= 1 + explodeFactor * 0.5;
                        brightness *= 1 + explodeFactor;
                        
                        const color = this.colors[i];
                        const whiteMix = Math.min(1, explodeFactor * 0.5);
                        color.r = color.r * (1 - whiteMix) + whiteMix;
                        color.g = color.g * (1 - whiteMix) + whiteMix;
                        color.b = color.b * (1 - whiteMix) + whiteMix;
                    }
                }
                
                return { scaleFactor };
            }
        };
        
        // 初始化Three.js
        function initThreeJS() {
            // 场景
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            
            // 相机
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 10);
            camera.lookAt(0, 0, 0);
            
            // 渲染器
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            // 辉光效果
            const renderScene = new THREE.RenderPass(scene, camera);
            bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                params.bloomStrength,
                params.bloomRadius,
                params.bloomThreshold
            );
            
            composer = new THREE.EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);
            
            // 初始化粒子系统
            initParticles();
            
            // 添加表演者
            addPerformer();
            
            // 窗口大小调整
            window.addEventListener('resize', onWindowResize);
            
            // 隐藏加载界面
            setTimeout(() => {
                document.getElementById('loading').classList.add('hidden');
            }, 1000);
        }
        
        // 初始化粒子
        function initParticles() {
            // 清空现有粒子
            particles.forEach(p => scene.remove(p));
            particles = [];
            
            // 初始化粒子系统
            particleSystem.init();
            
            // 创建几何体
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(params.particleCount * 3);
            const colors = new Float32Array(params.particleCount * 3);
            const sizes = new Float32Array(params.particleCount);
            
            // 设置初始属性
            for (let i = 0; i < params.particleCount; i++) {
                const pos = particleSystem.positions[i];
                const color = particleSystem.colors[i];
                
                positions[i * 3] = pos.x;
                positions[i * 3 + 1] = pos.y;
                positions[i * 3 + 2] = pos.z;
                
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
                
                sizes[i] = particleSystem.sizes[i];
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            // 材质
            const material = new THREE.PointsMaterial({
                size: params.baseSize,
                vertexColors: true,
                transparent: true,
                opacity: 0.9,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });
            
            // 粒子系统
            const particleSystemObj = new THREE.Points(geometry, material);
            scene.add(particleSystemObj);
            particles.push(particleSystemObj);
        }
        
        // 添加表演者
        function addPerformer() {
            const group = new THREE.Group();
            
            // 身体
            const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.4, 1.5, 8);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x333333,
                metalness: 0.7,
                roughness: 0.3
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.75;
            group.add(body);
            
            // 头部
            const headGeometry = new THREE.SphereGeometry(0.3, 16, 16);
            const headMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x444444,
                metalness: 0.7,
                roughness: 0.3
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.8;
            group.add(head);
            
            // 手臂
            const armGeometry = new THREE.CylinderGeometry(0.1, 0.1, 1.2, 8);
            const armMaterial = bodyMaterial.clone();
            
            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-0.6, 1.2, 0);
            leftArm.rotation.z = Math.PI / 4;
            group.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0.6, 1.2, 0);
            rightArm.rotation.z = -Math.PI / 4;
            group.add(rightArm);
            
            // 中心光源
            const centerLight = new THREE.PointLight(0xff6600, 2, 10);
            centerLight.position.set(0, 1.5, 0);
            group.add(centerLight);
            
            // 辉光球体
            const lightSphereGeometry = new THREE.SphereGeometry(0.2, 16, 16);
            const lightSphereMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xff6600,
                transparent: true,
                opacity: 0.7
            });
            const lightSphere = new THREE.Mesh(lightSphereGeometry, lightSphereMaterial);
            lightSphere.position.set(0, 1.5, 0);
            group.add(lightSphere);
            
            scene.add(group);
            
            // 旋转动画
            function animatePerformer() {
                group.rotation.y += 0.002;
            }
            
            // 添加到动画循环
            const originalAnimate = animate;
            animate = function() {
                originalAnimate();
                animatePerformer();
            };
        }
        
        // 手部检测
        async function initHandDetection() {
            try {
                handposeModel = await handpose.load();
                
                video = document.createElement('video');
                video.style.position = 'absolute';
                video.style.top = '0';
                video.style.left = '0';
                video.style.width = '160px';
                video.style.height = '120px';
                video.style.opacity = '0.7';
                video.style.zIndex = '10';
                document.getElementById('ui').appendChild(video);
                
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 640, height: 480, facingMode: 'user' }
                });
                
                video.srcObject = stream;
                video.play();
                
                detectHand();
                
            } catch (error) {
                console.error('手部检测失败:', error);
                document.addEventListener('wheel', (e) => {
                    handScale = Math.max(0.1, Math.min(1.0, handScale - e.deltaY * 0.001));
                });
            }
        }
        
        // 手部检测循环
        async function detectHand() {
            if (!handposeModel || !video) return;
            
            const predictions = await handposeModel.estimateHands(video);
            
            if (predictions.length > 0) {
                const hand = predictions[0];
                const thumbTip = hand.annotations.thumb[3];
                const pinkyTip = hand.annotations.pinky[3];
                
                const dx = thumbTip[0] - pinkyTip[0];
                const dy = thumbTip[1] - pinkyTip[1];
                const dz = thumbTip[2] - pinkyTip[2];
                const distance = Math.sqrt(dx*dx + dy*dy + dz*dz);
                
                handScale = Math.max(0.1, Math.min(1.0, distance / 150));
            }
            
            requestAnimationFrame(detectHand);
        }
        
        // 动画循环
        function animate() {
            requestAnimationFrame(animate);
            
            // 平滑手掌缩放值
            const smoothHandScale = lastHandScale + (handScale - lastHandScale) * 0.1;
            lastHandScale = smoothHandScale;
            
            // 更新粒子
            const { scaleFactor } = particleSystem.update(smoothHandScale);
            
            // 更新粒子系统显示
            if (particles.length > 0) {
                const particleSystemObj = particles[0];
                const geometry = particleSystemObj.geometry;
                const positions = geometry.attributes.position.array;
                const colors = geometry.attributes.color.array;
                const sizes = geometry.attributes.size.array;
                
                for (let i = 0; i < params.particleCount; i++) {
                    const pos = particleSystem.positions[i].clone().multiplyScalar(scaleFactor);
                    const color = particleSystem.colors[i];
                    
                    positions[i * 3] = pos.x;
                    positions[i * 3 + 1] = pos.y;
                    positions[i * 3 + 2] = pos.z;
                    
                    colors[i * 3] = color.r;
                    colors[i * 3 + 1] = color.g;
                    colors[i * 3 + 2] = color.b;
                    
                    sizes[i] = particleSystem.sizes[i];
                }
                
                geometry.attributes.position.needsUpdate = true;
                geometry.attributes.color.needsUpdate = true;
                geometry.attributes.size.needsUpdate = true;
                
                particleSystemObj.material.size = params.baseSize * scaleFactor;
                bloomPass.strength = params.bloomStrength * (0.5 + smoothHandScale * 1.5);
            }
            
            composer.render();
        }
        
        // 窗口大小调整
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // 全屏切换
        function toggleFullscreen() {
            const container = document.getElementById('canvas-container');
            
            if (!isFullscreen) {
                if (container.requestFullscreen) container.requestFullscreen();
                else if (container.webkitRequestFullscreen) container.webkitRequestFullscreen();
                else if (container.mozRequestFullScreen) container.mozRequestFullScreen();
                else if (container.msRequestFullscreen) container.msRequestFullscreen();
                isFullscreen = true;
                document.getElementById('fullscreen-btn').textContent = '退出全屏';
            } else {
                if (document.exitFullscreen) document.exitFullscreen();
                else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
                else if (document.mozCancelFullScreen) document.mozCancelFullScreen();
                else if (document.msExitFullscreen) document.msExitFullscreen();
                isFullscreen = false;
                document.getElementById('fullscreen-btn').textContent = '全屏';
            }
        }
        
        // 初始化UI事件
        function initUI() {
            document.getElementById('fullscreen-btn').addEventListener('click', toggleFullscreen);
            document.getElementById('reset-btn').addEventListener('click', initParticles);
            
            document.addEventListener('fullscreenchange', () => {
                isFullscreen = !!document.fullscreenElement;
                document.getElementById('fullscreen-btn').textContent = isFullscreen ? '退出全屏' : '全屏';
            });
            
            document.addEventListener('webkitfullscreenchange', () => {
                isFullscreen = !!document.webkitFullscreenElement;
                document.getElementById('fullscreen-btn').textContent = isFullscreen ? '退出全屏' : '全屏';
            });
        }
        
        // 初始化应用
        async function initApp() {
            initThreeJS();
            initUI();
            await initHandDetection();
            animate();
        }
        
        initApp();
    </script>
</body>
</html>
