<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D粒子打火花系统 - 修复版</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/handpose@0.0.7/dist/handpose.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core@2.7.0/dist/tf-core.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter@2.7.0/dist/tf-converter.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl@2.7.0/dist/tf-backend-webgl.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #000; color: #fff; }
        #canvas-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        #ui { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 2; pointer-events: none; }
        .ui-element {
            pointer-events: auto;
            position: absolute;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 215, 0, 0.6);
            border-radius: 8px;
            padding: 12px 20px;
            color: #ffd700;
            backdrop-filter: blur(4px);
            transition: all 0.3s;
        }
        .ui-element:hover { background: rgba(30, 30, 30, 0.8); border-color: #ffd700; }
        #title { top: 20px; left: 20px; font-size: 1.5rem; font-weight: bold; }
        #controls { top: 20px; right: 20px; display: flex; gap: 10px; }
        button {
            background: rgba(255, 69, 0, 0.7);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 8px 16px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }
        button:hover { background: rgba(255, 69, 0, 0.9); transform: translateY(-2px); }
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(255, 215, 0, 0.3);
            border-top: 5px solid #ffd700;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .hidden { display: none !important; }
        #error-message {
            color: #ff4500;
            margin-top: 20px;
            text-align: center;
            max-width: 80%;
        }
        #retry-btn {
            margin-top: 20px;
            background: rgba(255, 69, 0, 0.7);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 8px 16px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="ui">
        <div id="title" class="ui-element">3D粒子打火花系统</div>
        <div id="controls" class="ui-element">
            <button id="fullscreen-btn">全屏</button>
            <button id="reset-btn">重置粒子</button>
        </div>
    </div>
    
    <div id="loading">
        <div class="spinner"></div>
        <div>正在初始化系统...</div>
        <div id="loading-progress"></div>
        <div id="error-message" class="hidden"></div>
        <button id="retry-btn" class="hidden">重试</button>
    </div>

    <script>
        // 全局变量
        let scene, camera, renderer;
        let particles = [];
        let handposeModel = null;
        let video = null;
        let handScale = 1.0;
        let lastHandScale = 1.0;
        let isFullscreen = false;
        let isInitialized = false;
        let bloomScene, bloomCamera, bloomComposer;
        let renderTarget, renderTargetBright, renderTargetHorizontal, renderTargetVertical;
        
        // 参数配置
        const params = {
            particleCount: 1500,
            baseSize: 0.05,
            baseBrightness: 1.0,
            maxSpeed: 0.5,
            maxOrbitRadius: 6,
            bloomStrength: 1.5
        };
        
        // 粒子系统
        const particleSystem = {
            particles: [],
            positions: [],
            velocities: [],
            sizes: [],
            brightness: [],
            colors: [],
            orbitParams: [],
            chaosFactor: 0,
            noiseOffset: 0,
            
            init() {
                this.particles = new Array(params.particleCount);
                this.positions = new Array(params.particleCount);
                this.velocities = new Array(params.particleCount);
                this.sizes = new Array(params.particleCount);
                this.brightness = new Array(params.particleCount);
                this.colors = new Array(params.particleCount);
                this.orbitParams = new Array(params.particleCount);
                
                this.chaosFactor = 0;
                this.noiseOffset = 0;
                
                for (let i = 0; i < params.particleCount; i++) {
                    // 轨道参数
                    const a = 1 + Math.random() * (params.maxOrbitRadius - 1);
                    const e = 0.2 + Math.random() * 0.7;
                    const i = Math.random() * Math.PI;
                    const ω = Math.random() * 2 * Math.PI;
                    const M = Math.random() * 2 * Math.PI;
                    
                    // 计算初始位置
                    const E = this.solveKepler(M, e);
                    const xOrbit = a * (Math.cos(E) - e);
                    const yOrbit = a * Math.sqrt(1 - e * e) * Math.sin(E);
                    
                    // 应用轨道参数
                    const cosω = Math.cos(ω);
                    const sinω = Math.sin(ω);
                    const cosi = Math.cos(i);
                    const sini = Math.sin(i);
                    
                    const x = (cosω * xOrbit - sinω * yOrbit);
                    const z = (sinω * xOrbit + cosω * yOrbit) * cosi;
                    const y = (sinω * xOrbit + cosω * yOrbit) * sini;
                    
                    // 存储轨道参数
                    this.orbitParams[i] = { a, e, i, ω, M };
                    
                    // 初始位置和速度
                    this.positions[i] = new THREE.Vector3(x, y, z);
                    
                    const r = Math.sqrt(x*x + y*y + z*z);
                    const speed = Math.sqrt(2/r - 1/a) * 0.5;
                    
                    const velocityDir = new THREE.Vector3(-z, 0, x).normalize();
                    if (velocityDir.length() === 0) velocityDir.set(1, 0, 0);
                    velocityDir.applyAxisAngle(new THREE.Vector3(1, 0, 0), i);
                    
                    this.velocities[i] = velocityDir.multiplyScalar(speed);
                    
                    // 粒子属性
                    this.sizes[i] = params.baseSize * (0.5 + Math.random() * 1.5);
                    this.brightness[i] = 0.5 + Math.random() * 0.5;
                    
                    // 颜色（从橙色到红色到黄色）
                    const h = 0.05 + Math.random() * 0.1;
                    const s = 0.8 + Math.random() * 0.2;
                    const v = 0.8 + Math.random() * 0.2;
                    
                    const color = new THREE.Color();
                    color.setHSL(h, s, v);
                    this.colors[i] = color;
                }
            },
            
            solveKepler(M, e, iterations = 5) {
                let E = M;
                for (let i = 0; i < iterations; i++) {
                    E = M + e * Math.sin(E);
                }
                return E;
            },
            
            update(smoothHandScale) {
                const scaleFactor = 0.5 + smoothHandScale * 2.5;
                const chaosFactor = Math.max(0, (scaleFactor - 2) * 2);
                this.chaosFactor = chaosFactor;
                this.noiseOffset += 0.01;
                
                for (let i = 0; i < params.particleCount; i++) {
                    const pos = this.positions[i];
                    const vel = this.velocities[i];
                    const { a } = this.orbitParams[i];
                    
                    // 引力计算
                    const distance = pos.length();
                    const gravityStrength = 0.1 / (distance * distance + 0.01);
                    const gravity = pos.clone().multiplyScalar(-gravityStrength);
                    vel.add(gravity);
                    
                    // 混沌效果
                    if (chaosFactor > 0) {
                        // 布朗运动
                        vel.add(new THREE.Vector3(
                            (Math.random() - 0.5) * 0.02 * chaosFactor,
                            (Math.random() - 0.5) * 0.02 * chaosFactor,
                            (Math.random() - 0.5) * 0.02 * chaosFactor
                        ));
                        
                        // 噪点运动
                        vel.x += Math.sin(i + this.noiseOffset * 10) * 0.01 * chaosFactor;
                        vel.y += Math.cos(i * 2 + this.noiseOffset * 8) * 0.01 * chaosFactor;
                        vel.z += Math.sin(i * 3 + this.noiseOffset * 12) * 0.01 * chaosFactor;
                    }
                    
                    // 速度限制
                    if (vel.length() > params.maxSpeed) {
                        vel.normalize().multiplyScalar(params.maxSpeed);
                    }
                    
                    // 更新位置
                    pos.add(vel);
                    
                    // 屏幕空间位置
                    const screenPos = pos.clone().multiplyScalar(scaleFactor).project(camera);
                    
                    // 粒子属性
                    let particleSize = this.sizes[i] * scaleFactor;
                    let brightness = this.brightness[i] * Math.pow(scaleFactor, 2);
                    
                    // 屏幕边缘效果
                    const screenEdgeFactor = Math.max(Math.abs(screenPos.x), Math.abs(screenPos.y));
                    if (screenEdgeFactor > 0.8) {
                        const edgeFactor = (screenEdgeFactor - 0.8) * 5;
                        vel.x += (Math.random() - 0.5) * 0.1 * edgeFactor;
                        vel.y += (Math.random() - 0.5) * 0.1 * edgeFactor;
                        vel.z += (Math.random() - 0.5) * 0.1 * edgeFactor;
                        brightness *= 1 + Math.sin(Date.now() * 0.01 + i) * 0.5;
                    }
                    
                    // 炸开效果
                    if (scaleFactor > 2.5) {
                        const explodeFactor = (scaleFactor - 2.5) * 2;
                        vel.add(pos.clone().normalize().multiplyScalar(0.05 * explodeFactor));
                        particleSize *= 1 + explodeFactor * 0.5;
                        brightness *= 1 + explodeFactor;
                        
                        const color = this.colors[i];
                        const whiteMix = Math.min(1, explodeFactor * 0.5);
                        color.r = color.r * (1 - whiteMix) + whiteMix;
                        color.g = color.g * (1 - whiteMix) + whiteMix;
                        color.b = color.b * (1 - whiteMix) + whiteMix;
                    }
                }
                
                return { scaleFactor };
            }
        };
        
        // 更新加载状态
        function updateLoadingStatus(message) {
            const progressElement = document.getElementById('loading-progress');
            if (progressElement) {
                progressElement.textContent = message;
            }
        }
        
        // 显示错误信息
        function showError(message) {
            const errorElement = document.getElementById('error-message');
            const retryButton = document.getElementById('retry-btn');
            
            if (errorElement && retryButton) {
                errorElement.textContent = message;
                errorElement.classList.remove('hidden');
                retryButton.classList.remove('hidden');
                
                // 隐藏加载动画
                const spinner = document.querySelector('.spinner');
                if (spinner) spinner.style.display = 'none';
            }
        }
        
        // 隐藏加载界面
        function hideLoading() {
            const loadingElement = document.getElementById('loading');
            if (loadingElement) {
                loadingElement.classList.add('hidden');
            }
        }
        
        // 初始化Three.js
        async function initThreeJS() {
            try {
                updateLoadingStatus('初始化Three.js场景...');
                
                // 创建场景
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x000000);
                
                // 创建相机
                camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 2, 10);
                camera.lookAt(0, 0, 0);
                
                // 创建渲染器
                updateLoadingStatus('创建WebGL渲染器...');
                renderer = new THREE.WebGLRenderer({ 
                    antialias: true, 
                    alpha: true,
                    powerPreference: "high-performance"
                });
                
                // 检查WebGL支持
                if (!renderer.getContext()) {
                    throw new Error('您的浏览器不支持WebGL或WebGL已被禁用');
                }
                
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(2, window.devicePixelRatio));
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                
                document.getElementById('canvas-container').appendChild(renderer.domElement);
                
                // 添加光源
                const ambientLight = new THREE.AmbientLight(0x222222);
                scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffd700, 1);
                directionalLight.position.set(5, 10, 7);
                directionalLight.castShadow = true;
                scene.add(directionalLight);
                
                // 初始化粒子
                updateLoadingStatus('创建粒子系统...');
                initParticles();
                
                // 添加表演者
                updateLoadingStatus('添加表演者模型...');
                addPerformer();
                
                // 窗口大小调整
                window.addEventListener('resize', onWindowResize);
                
                return true;
            } catch (error) {
                console.error('Three.js初始化失败:', error);
                showError(`Three.js初始化失败: ${error.message}`);
                return false;
            }
        }
        
        // 初始化粒子
        function initParticles() {
            try {
                // 清空现有粒子
                if (particles.length > 0) {
                    particles.forEach(p => {
                        if (p && scene) {
                            scene.remove(p);
                        }
                    });
                }
                particles = [];
                
                // 初始化粒子系统
                particleSystem.init();
                
                // 创建几何体
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(params.particleCount * 3);
                const colors = new Float32Array(params.particleCount * 3);
                const sizes = new Float32Array(params.particleCount);
                
                // 设置初始属性
                for (let i = 0; i < params.particleCount; i++) {
                    const pos = particleSystem.positions[i];
                    const color = particleSystem.colors[i];
                    
                    // 确保位置和颜色已正确初始化
                    if (!pos || !color) {
                        throw new Error(`粒子${i}的位置或颜色未正确初始化`);
                    }
                    
                    positions[i * 3] = pos.x;
                    positions[i * 3 + 1] = pos.y;
                    positions[i * 3 + 2] = pos.z;
                    
                    colors[i * 3] = color.r;
                    colors[i * 3 + 1] = color.g;
                    colors[i * 3 + 2] = color.b;
                    
                    sizes[i] = particleSystem.sizes[i];
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                
                // 材质
                const material = new THREE.PointsMaterial({
                    size: params.baseSize,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.9,
                    blending: THREE.AdditiveBlending,
                    sizeAttenuation: true
                });
                
                // 粒子系统
                const particleSystemObj = new THREE.Points(geometry, material);
                scene.add(particleSystemObj);
                particles.push(particleSystemObj);
                
                return true;
            } catch (error) {
                console.error('粒子初始化失败:', error);
                showError(`粒子初始化失败: ${error.message}`);
                return false;
            }
        }
        
        // 添加表演者
        function addPerformer() {
            const group = new THREE.Group();
            
            // 身体
            const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.4, 1.5, 8);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x333333,
                metalness: 0.7,
                roughness: 0.3
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.75;
            group.add(body);
            
            // 头部
            const headGeometry = new THREE.SphereGeometry(0.3, 16, 16);
            const headMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x444444,
                metalness: 0.7,
                roughness: 0.3
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.8;
            group.add(head);
            
            // 手臂
            const armGeometry = new THREE.CylinderGeometry(0.1, 0.1, 1.2, 8);
            const armMaterial = bodyMaterial.clone();
            
            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-0.6, 1.2, 0);
            leftArm.rotation.z = Math.PI / 4;
            group.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0.6, 1.2, 0);
            rightArm.rotation.z = -Math.PI / 4;
            group.add(rightArm);
            
            // 中心光源
            const centerLight = new THREE.PointLight(0xff6600, 2, 10);
            centerLight.position.set(0, 1.5, 0);
            group.add(centerLight);
            
            // 辉光球体
            const lightSphereGeometry = new THREE.SphereGeometry(0.2, 16, 16);
            const lightSphereMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xff6600,
                transparent: true,
                opacity: 0.7
            });
            const lightSphere = new THREE.Mesh(lightSphereGeometry, lightSphereMaterial);
            lightSphere.position.set(0, 1.5, 0);
            group.add(lightSphere);
            
            scene.add(group);
            
            // 旋转动画
            function animatePerformer() {
                group.rotation.y += 0.002;
            }
            
            // 添加到动画循环
            const originalAnimate = animate;
            animate = function() {
                originalAnimate();
                animatePerformer();
            };
        }
        
        // 手部检测
        async function initHandDetection() {
            try {
                updateLoadingStatus('加载手部检测模型...');
                
                // 设置TensorFlow.js后端
                await tf.setBackend('webgl');
                await tf.ready();
                
                // 加载手部检测模型
                handposeModel = await handpose.load();
                
                updateLoadingStatus('启动摄像头...');
                
                video = document.createElement('video');
                video.style.position = 'absolute';
                video.style.top = '0';
                video.style.left = '0';
                video.style.width = '160px';
                video.style.height = '120px';
                video.style.opacity = '0.7';
                video.style.zIndex = '10';
                document.getElementById('ui').appendChild(video);
                
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        width: 640, 
                        height: 480, 
                        facingMode: 'user',
                        frameRate: { ideal: 30 }
                    }
                }).catch(error => {
                    throw new Error(`摄像头访问被拒绝: ${error.message}`);
                });
                
                video.srcObject = stream;
                await video.play();
                
                // 开始手部检测
                detectHand();
                
                return true;
            } catch (error) {
                console.error('手部检测初始化失败:', error);
                showError(`手部检测不可用: ${error.message}`);
                
                // 使用鼠标滚轮作为备用控制
                document.addEventListener('wheel', (e) => {
                    handScale = Math.max(0.1, Math.min(1.0, handScale - e.deltaY * 0.001));
                });
                
                return false;
            }
        }
        
        // 手部检测循环
        async function detectHand() {
            if (!handposeModel || !video) return;
            
            try {
                const predictions = await handposeModel.estimateHands(video);
                
                if (predictions.length > 0) {
                    const hand = predictions[0];
                    const thumbTip = hand.annotations.thumb[3];
                    const pinkyTip = hand.annotations.pinky[3];
                    
                    const dx = thumbTip[0] - pinkyTip[0];
                    const dy = thumbTip[1] - pinkyTip[1];
                    const dz = thumbTip[2] - pinkyTip[2];
                    const distance = Math.sqrt(dx*dx + dy*dy + dz*dz);
                    
                    handScale = Math.max(0.1, Math.min(1.0, distance / 150));
                }
            } catch (error) {
                console.error('手部检测错误:', error);
            }
            
            requestAnimationFrame(detectHand);
        }
        
        // 动画循环
        function animate() {
            if (!isInitialized) return;
            
            requestAnimationFrame(animate);
            
            // 平滑手掌缩放值
            const smoothHandScale = lastHandScale + (handScale - lastHandScale) * 0.1;
            lastHandScale = smoothHandScale;
            
            // 更新粒子
            const { scaleFactor } = particleSystem.update(smoothHandScale);
            
            // 更新粒子系统显示
            if (particles.length > 0) {
                const particleSystemObj = particles[0];
                const geometry = particleSystemObj.geometry;
                const positions = geometry.attributes.position.array;
                const colors = geometry.attributes.color.array;
                const sizes = geometry.attributes.size.array;
                
                for (let i = 0; i < params.particleCount; i++) {
                    const pos = particleSystem.positions[i];
                    const color = particleSystem.colors[i];
                    
                    // 确保位置和颜色已正确初始化
                    if (!pos || !color) continue;
                    
                    const scaledPos = pos.clone().multiplyScalar(scaleFactor);
                    
                    positions[i * 3] = scaledPos.x;
                    positions[i * 3 + 1] = scaledPos.y;
                    positions[i * 3 + 2] = scaledPos.z;
                    
                    colors[i * 3] = color.r;
                    colors[i * 3 + 1] = color.g;
                    colors[i * 3 + 2] = color.b;
                    
                    sizes[i] = particleSystem.sizes[i];
                }
                
                geometry.attributes.position.needsUpdate = true;
                geometry.attributes.color.needsUpdate = true;
                geometry.attributes.size.needsUpdate = true;
                
                particleSystemObj.material.size = params.baseSize * scaleFactor;
            }
            
            renderer.render(scene, camera);
        }
        
        // 窗口大小调整
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // 全屏切换
        function toggleFullscreen() {
            const container = document.getElementById('canvas-container');
            
            if (!isFullscreen) {
                if (container.requestFullscreen) container.requestFullscreen();
                else if (container.webkitRequestFullscreen) container.webkitRequestFullscreen();
                else if (container.mozRequestFullScreen) container.mozRequestFullScreen();
                else if (container.msRequestFullscreen) container.msRequestFullscreen();
                isFullscreen = true;
                document.getElementById('fullscreen-btn').textContent = '退出全屏';
            } else {
                if (document.exitFullscreen) document.exitFullscreen();
                else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
                else if (document.mozCancelFullScreen) document.mozCancelFullScreen();
                else if (document.msExitFullscreen) document.msExitFullscreen();
                isFullscreen = false;
                document.getElementById('fullscreen-btn').textContent = '全屏';
            }
        }
        
        // 初始化UI事件
        function initUI() {
            document.getElementById('fullscreen-btn').addEventListener('click', toggleFullscreen);
            document.getElementById('reset-btn').addEventListener('click', initParticles);
            document.getElementById('retry-btn').addEventListener('click', initApp);
            
            document.addEventListener('fullscreenchange', () => {
                isFullscreen = !!document.fullscreenElement;
                document.getElementById('fullscreen-btn').textContent = isFullscreen ? '退出全屏' : '全屏';
            });
            
            document.addEventListener('webkitfullscreenchange', () => {
                isFullscreen = !!document.webkitFullscreenElement;
                document.getElementById('fullscreen-btn').textContent = isFullscreen ? '退出全屏' : '全屏';
            });
        }
        
        // 初始化应用
        async function initApp() {
            try {
                // 重置状态
                document.getElementById('error-message').classList.add('hidden');
                document.getElementById('retry-btn').classList.add('hidden');
                document.querySelector('.spinner').style.display = '';
                
                // 初始化Three.js
                const threeJsSuccess = await initThreeJS();
                if (!threeJsSuccess) return;
                
                // 初始化UI
                initUI();
                
                // 初始化手部检测
                await initHandDetection();
                
                // 标记为已初始化
                isInitialized = true;
                
                // 开始动画
                animate();
                
                // 隐藏加载界面
                setTimeout(hideLoading, 500);
            } catch (error) {
                console.error('应用初始化失败:', error);
                showError(`初始化失败: ${error.message}`);
            }
        }
        
        // 启动应用
        initApp();
    </script>
</body>
</html>
