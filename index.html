<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç²’å­åœŸæ˜Ÿ | äº¤äº’å¼å¤ªç©ºä½“éªŒ</title>
    
    <!-- Three.jsåº“ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- MediaPipeæ‰‹åŠ¿è¯†åˆ«åº“ -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        :root {
            --primary-gold: #c5a059;
            --secondary-blue: #59a0c5;
            --deep-space: #050505;
            --mid-space: #0b0b10;
            --ui-bg: rgba(10, 10, 15, 0.85);
            --transition-speed: 0.3s;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            background-color: var(--deep-space);
            font-family: 'Microsoft YaHei', 'Segoe UI', system-ui, sans-serif;
            color: white;
            user-select: none;
            touch-action: none;
            width: 100vw;
            height: 100vh;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
            z-index: 1;
            background: radial-gradient(ellipse at center, var(--deep-space) 0%, var(--mid-space) 70%, #151520 100%);
        }

        #ui-layer {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 10;
            pointer-events: none;
            transition: opacity var(--transition-speed) ease;
        }

        .glass-panel {
            background: var(--ui-bg);
            backdrop-filter: blur(15px) saturate(180%);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(197, 160, 89, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            max-width: 280px;
            transition: all var(--transition-speed) ease;
        }

        .glass-panel:hover {
            transform: translateY(-2px);
            border-color: rgba(197, 160, 89, 0.3);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.6);
        }

        h1 {
            font-weight: 300;
            font-size: 1.6rem;
            margin: 0 0 10px 0;
            color: #e0cda7;
            letter-spacing: 3px;
            text-transform: uppercase;
        }

        h2 {
            font-weight: 300;
            font-size: 1.2rem;
            margin: 0 0 15px 0;
            color: #e0cda7;
        }

        .status-text {
            font-size: 0.85rem;
            color: #aaa;
            line-height: 1.5;
            font-family: 'Courier New', monospace;
        }

        .highlight {
            color: var(--primary-gold);
            font-weight: 600;
        }

        #controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 10;
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        #author-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 20;
            pointer-events: auto;
            text-decoration: none;
            color: var(--primary-gold);
            border: 1px solid rgba(197, 160, 89, 0.3);
            background: rgba(10, 10, 15, 0.6);
            padding: 8px 18px;
            font-size: 0.8rem;
            border-radius: 20px;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            letter-spacing: 1px;
            font-family: monospace;
        }

        #author-btn:hover {
            background: var(--primary-gold);
            color: #000;
            box-shadow: 0 0 20px rgba(197, 160, 89, 0.4);
        }

        button {
            background: rgba(20, 20, 28, 0.6);
            border: 1px solid rgba(197, 160, 89, 0.25);
            color: var(--primary-gold);
            padding: 10px 24px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            border-radius: 6px;
            backdrop-filter: blur(8px);
            outline: none;
            min-width: 160px;
        }

        button:hover {
            background: rgba(197, 160, 89, 0.12);
            border-color: var(--primary-gold);
            box-shadow: 0 0 20px rgba(197, 160, 89, 0.25);
            transform: translateY(-2px);
        }

        button:active {
            transform: translateY(0);
        }

        button.active {
            background: rgba(197, 160, 89, 0.18);
            border-color: var(--primary-gold);
            box-shadow: 0 0 15px rgba(197, 160, 89, 0.3);
        }

        #loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 999;
            background: var(--deep-space);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 0.5s ease;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(197, 160, 89, 0.1);
            border-top-color: var(--primary-gold);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        #loading-message {
            color: #888;
            font-size: 0.9rem;
            letter-spacing: 2px;
            text-transform: uppercase;
            text-align: center;
            line-height: 1.5;
        }

        #fps-counter {
            position: fixed;
            top: 10px;
            left: 10px;
            color: #777;
            font-family: monospace;
            font-size: 11px;
            z-index: 5;
            background: rgba(0, 0, 0, 0.3);
            padding: 4px 8px;
            border-radius: 3px;
            backdrop-filter: blur(4px);
        }

        #performance-panel {
            position: fixed;
            bottom: 230px;
            left: 20px;
            z-index: 10;
            pointer-events: auto;
        }

        .performance-option {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            cursor: pointer;
            padding: 4px 0;
        }

        .performance-option input[type="radio"] {
            appearance: none;
            width: 16px;
            height: 16px;
            border: 2px solid rgba(197, 160, 89, 0.3);
            border-radius: 50%;
            margin-right: 10px;
            position: relative;
            cursor: pointer;
            transition: all 0.2s;
        }

        .performance-option input[type="radio"]:checked {
            border-color: var(--primary-gold);
            background: radial-gradient(circle, var(--primary-gold) 40%, transparent 41%);
        }

        .performance-option label {
            font-size: 0.8rem;
            color: #ccc;
            cursor: pointer;
        }

        #gesture-guide {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 98;
            background: rgba(5, 5, 10, 0.95);
            padding: 25px;
            border-radius: 15px;
            text-align: center;
            max-width: 320px;
            backdrop-filter: blur(25px);
            border: 1px solid rgba(197, 160, 89, 0.2);
            transition: opacity 0.4s ease;
        }

        #gesture-guide.hidden {
            opacity: 0;
            pointer-events: none;
        }

        #gesture-guide h3 {
            color: var(--primary-gold);
            margin-top: 0;
            font-weight: 300;
            font-size: 1.3rem;
            margin-bottom: 15px;
        }

        .gesture-demo {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
            gap: 20px;
        }

        .gesture-item {
            text-align: center;
        }

        .gesture-icon {
            width: 60px;
            height: 60px;
            background: rgba(197, 160, 89, 0.1);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 12px;
            font-size: 24px;
            border: 1px solid rgba(197, 160, 89, 0.1);
        }

        .input_video { 
            display: none; 
        }

        #saturn-info-panel {
            position: fixed;
            top: 100px;
            right: 20px;
            z-index: 10;
            pointer-events: auto;
            max-width: 300px;
            transition: opacity var(--transition-speed) ease;
        }

        .info-section {
            margin-bottom: 18px;
        }

        .info-section h3 {
            color: var(--primary-gold);
            font-size: 0.9rem;
            margin-bottom: 8px;
            border-bottom: 1px solid rgba(197, 160, 89, 0.15);
            padding-bottom: 6px;
            font-weight: 400;
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
            font-size: 0.8rem;
            padding: 3px 0;
        }

        .info-label {
            color: #aaa;
        }

        .info-value {
            color: #fff;
            text-align: right;
            font-family: 'Courier New', monospace;
        }

        .info-note {
            font-size: 0.7rem;
            color: #666;
            margin-top: 4px;
            font-style: italic;
        }

        #info-update-time {
            font-size: 0.7rem;
            color: #777;
            margin-top: 12px;
            text-align: right;
            border-top: 1px solid rgba(255, 255, 255, 0.05);
            padding-top: 8px;
        }

        /* éŸ³ä¹æ§åˆ¶æ ·å¼ */
        #music-controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            z-index: 10;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #music-toggle {
            background: rgba(20, 20, 28, 0.6);
            border: 1px solid rgba(197, 160, 89, 0.25);
            color: var(--primary-gold);
            padding: 8px 16px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: 6px;
            backdrop-filter: blur(8px);
            outline: none;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #music-toggle:hover {
            background: rgba(197, 160, 89, 0.12);
            border-color: var(--primary-gold);
        }

        #volume-control {
            width: 100px;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
        }

        #volume-control::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--primary-gold);
            cursor: pointer;
        }

        #volume-control::-moz-range-thumb {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--primary-gold);
            cursor: pointer;
            border: none;
        }

        /* å“åº”å¼è®¾è®¡ */
        @media (max-width: 768px) {
            .glass-panel {
                max-width: calc(100vw - 40px);
                padding: 15px;
            }
            
            #controls {
                bottom: 10px;
                right: 10px;
                gap: 8px;
            }
            
            #performance-panel {
                bottom: 250px;
                left: 10px;
            }
            
            #saturn-info-panel {
                top: 80px;
                right: 10px;
                max-width: calc(100vw - 40px);
            }
            
            #ui-layer {
                top: 10px;
                left: 10px;
            }
            
            #author-btn {
                top: 10px;
                right: 10px;
                padding: 6px 12px;
                font-size: 0.7rem;
            }
            
            button {
                padding: 8px 16px;
                font-size: 0.75rem;
                min-width: 120px;
            }
            
            #music-controls {
                bottom: 10px;
                left: 10px;
            }
            
            h1 {
                font-size: 1.3rem;
            }
            
            .gesture-demo {
                flex-direction: column;
                gap: 15px;
            }
            
            .status-text {
                font-size: 0.75rem;
            }
        }

        @media (max-width: 480px) {
            #controls {
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: flex-end;
            }
            
            button {
                min-width: 110px;
                padding: 6px 12px;
                font-size: 0.7rem;
            }
            
            #performance-panel {
                bottom: 280px;
            }
            
            #music-controls {
                flex-direction: column;
                align-items: flex-start;
                gap: 5px;
            }
            
            #volume-control {
                width: 80px;
            }
        }

        @media (max-height: 600px) {
            #saturn-info-panel {
                top: 60px;
                max-height: calc(100vh - 120px);
                overflow-y: auto;
            }
            
            #performance-panel {
                bottom: 200px;
            }
        }
    </style>
</head>
<body>
    <video class="input_video"></video>
    
    <!-- èƒŒæ™¯éŸ³ä¹ -->
    <audio id="background-music" loop>
        <source src="https://assets.codepen.io/1468070/space-ambient.mp3" type="audio/mpeg">
        <source src="https://assets.codepen.io/1468070/space-ambient.ogg" type="audio/ogg">
    </audio>
    
    <div id="loading-overlay">
        <div class="loading-spinner"></div>
        <div id="loading-message">
            åˆå§‹åŒ–ç²’å­ç³»ç»Ÿ...<br>
            <span style="color: #666; font-size: 0.8rem;">åŠ è½½ä¸­</span>
        </div>
    </div>

    <a id="author-btn" href="https://www.yjln.com" target="_blank" rel="noopener">By Cannis_GU</a>

    <div id="fps-counter">å‡†å¤‡ä¸­...</div>

    <div id="gesture-guide" class="hidden">
        <h3>æ‰‹åŠ¿æ§åˆ¶æŒ‡å—</h3>
        <p style="color: #bbb; margin-bottom: 20px; font-size: 0.85rem;">ä¼¸å‡ºæ‰‹è¿›å…¥æ‘„åƒå¤´è§†é‡å³å¯å¼€å§‹æ§åˆ¶</p>
        <div class="gesture-demo">
            <div class="gesture-item">
                <div class="gesture-icon">ğŸ“</div>
                <div>æåˆç¼©æ”¾</div>
            </div>
            <div class="gesture-item">
                <div class="gesture-icon">ğŸ”„</div>
                <div>æ‰‹æŒç§»åŠ¨æ—‹è½¬</div>
            </div>
        </div>
        <button onclick="hideGestureGuide()" style="margin-top: 15px;">å¼€å§‹æ¢ç´¢</button>
    </div>

    <div id="ui-layer">
        <div class="glass-panel">
            <h1>SATURN</h1>
            <div class="status-text">
                <span class="highlight">â€º</span> æ•°æ®æµçŠ¶æ€: 
                <span id="status-indicator" class="highlight">åŒæ­¥ä¸­</span>
                <br><br>
                <span class="highlight">âœ“</span> å¼€æ™®å‹’è½¨é“: <span class="highlight">ç¨³å®š</span><br>
                <span class="highlight">âœ§</span> ç²’å­æ€»é‡: <span id="particle-count">--</span><br>
                <span class="highlight">âš¡</span> æ¸²æŸ“æ¨¡å¼: <span id="performance-mode">è‡ªé€‚åº”</span>
            </div>
        </div>
    </div>

    <div id="saturn-info-panel" class="glass-panel">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
            <h2>åœŸæ˜Ÿæ•°æ®</h2>
            <button onclick="toggleDataPanel()" style="padding: 4px 12px; font-size: 0.7rem; min-width: auto;">
                â–²
            </button>
        </div>
        
        <div class="info-section">
            <h3>å¤©æ–‡ä½ç½®</h3>
            <div class="info-item">
                <span class="info-label">è·åœ°çƒ:</span>
                <span class="info-value" id="distance-earth">13.5äº¿å…¬é‡Œ</span>
            </div>
            <div class="info-item">
                <span class="info-label">è·å¤ªé˜³:</span>
                <span class="info-value">14.27äº¿å…¬é‡Œ</span>
            </div>
            <div class="info-item">
                <span class="info-label">æ‰€åœ¨æ˜Ÿåº§:</span>
                <span class="info-value">å®ç“¶åº§</span>
            </div>
            <div class="info-item">
                <span class="info-label">äº®åº¦:</span>
                <span class="info-value">0.46ç­‰</span>
            </div>
            <div class="info-note">æ•°æ®åŸºäºå½“å‰å¤©æ–‡è§‚æµ‹æ—¶é—´ä¼°ç®—</div>
        </div>
        
        <div class="info-section">
            <h3>ç‰©ç†ç‰¹å¾</h3>
            <div class="info-item">
                <span class="info-label">èµ¤é“ç›´å¾„:</span>
                <span class="info-value">120,536 km</span>
            </div>
            <div class="info-item">
                <span class="info-label">è´¨é‡:</span>
                <span class="info-value">5.683Ã—10Â²â¶ kg</span>
            </div>
            <div class="info-item">
                <span class="info-label">å¯†åº¦:</span>
                <span class="info-value">0.687 g/cmÂ³</span>
            </div>
            <div class="info-item">
                <span class="info-label">è‡ªè½¬å‘¨æœŸ:</span>
                <span class="info-value">10.7 å°æ—¶</span>
            </div>
            <div class="info-item">
                <span class="info-label">å…¬è½¬å‘¨æœŸ:</span>
                <span class="info-value">29.4571 å¹´</span>
            </div>
            <div class="info-note">èµ„æ–™æ¥æº: NASA JPL Horizons System</div>
        </div>
        
        <div class="info-section">
            <h3>ç¯ç³»ä¸å«æ˜Ÿ</h3>
            <div class="info-item">
                <span class="info-label">ä¸»è¦ç¯å¸¦:</span>
                <span class="info-value">7ç»„</span>
            </div>
            <div class="info-item">
                <span class="info-label">ç¯ç³»æ€»å®½:</span>
                <span class="info-value">282,000 km</span>
            </div>
            <div class="info-item">
                <span class="info-label">ç¡®è®¤å«æ˜Ÿ:</span>
                <span class="info-value highlight">146é¢—</span>
            </div>
            <div class="info-item">
                <span class="info-label">æœ€å¤§å«æ˜Ÿ:</span>
                <span class="info-value">åœŸå«å…­(æ³°å¦)</span>
            </div>
        </div>
        
        <div id="info-update-time">
            æ›´æ–°æ—¶é—´: <span id="data-time">--</span>
        </div>
    </div>

    <div id="performance-panel" class="glass-panel">
        <h3 style="margin-bottom: 15px;">æ€§èƒ½è®¾ç½®</h3>
        <div class="performance-option">
            <input type="radio" id="performance-low" name="performance" value="low">
            <label for="performance-low">èŠ‚èƒ½æ¨¡å¼ (30ä¸‡ç²’å­)</label>
        </div>
        <div class="performance-option">
            <input type="radio" id="performance-balanced" name="performance" value="balanced" checked>
            <label for="performance-balanced">å‡è¡¡æ¨¡å¼ (60ä¸‡ç²’å­)</label>
        </div>
        <div class="performance-option">
            <input type="radio" id="performance-high" name="performance" value="high">
            <label for="performance-high">é«˜å“è´¨æ¨¡å¼ (90ä¸‡ç²’å­)</label>
        </div>
    </div>

    <!-- éŸ³ä¹æ§åˆ¶ -->
    <div id="music-controls">
        <button id="music-toggle" onclick="toggleMusic()">
            <span id="music-icon">ğŸ”‡</span>
            <span id="music-text">èƒŒæ™¯éŸ³ä¹</span>
        </button>
        <input type="range" id="volume-control" min="0" max="1" step="0.1" value="0.5">
    </div>

    <div id="controls">
        <button onclick="toggleFullScreen()" id="fullscreen-btn">å…¨å±æ²‰æµ¸</button>
        <button onclick="toggleUI()" id="toggle-ui-btn">éšè—ç•Œé¢</button>
        <button onclick="resetView()" id="reset-view-btn">é‡ç½®è§†å›¾</button>
        <button onclick="toggleHandTracking()" id="toggle-hand-btn">æ‰‹åŠ¿æ§åˆ¶</button>
    </div>

    <div id="canvas-container"></div>

    <!-- ç€è‰²å™¨ä»£ç  -->
    <script type="x-shader/x-vertex" id="vertexshader">
        attribute float size;
        attribute vec3 customColor;
        attribute float opacityAttr;
        attribute float orbitSpeed;
        attribute float isRing;
        attribute float aRandomId;
        
        varying vec3 vColor;
        varying float vDist;
        varying float vOpacity;
        varying float vScaleFactor;
        varying float vIsRing;
        
        uniform float uTime;
        uniform float uScale;
        uniform float uRotationX;
        
        mat2 rotate2d(float angle){
            return mat2(cos(angle), -sin(angle),
                        sin(angle), cos(angle));
        }

        float hash(float n) { 
            return fract(sin(n) * 43758.5453123); 
        }

        void main() {
            float scaleNorm = (uScale - 0.1) / 2.5;
            float lodThreshold = 0.93 + pow(clamp(scaleNorm, 0.0, 1.0), 1.3) * 0.06;

            if (aRandomId > lodThreshold) {
                gl_Position = vec4(0.0);
                gl_PointSize = 0.0;
                return;
            }

            vec3 pos = position;

            if (isRing > 0.5) {
                float ringAngle = uTime * orbitSpeed * 0.17;
                vec2 rotatedXZ = rotate2d(ringAngle) * pos.xz;
                pos.x = rotatedXZ.x;
                pos.z = rotatedXZ.y;
            } else {
                float bodyAngle = uTime * 0.027;
                vec2 rotatedXZ = rotate2d(bodyAngle) * pos.xz;
                pos.x = rotatedXZ.x;
                pos.z = rotatedXZ.y;
            }

            float cx = cos(uRotationX);
            float sx = sin(uRotationX);
            float ry = pos.y * cx - pos.z * sx;
            float rz = pos.y * sx + pos.z * cx;
            pos.y = ry;
            pos.z = rz;

            vec4 mvPosition = modelViewMatrix * vec4(pos * uScale, 1.0);
            float dist = -mvPosition.z;
            vDist = dist;

            float turbulenceThreshold = 22.0;
            if (dist < turbulenceThreshold && dist > 0.01) {
                float intensity = 1.0 - (dist / turbulenceThreshold);
                intensity = pow(intensity, 2.7) * 0.012;

                float noiseTime = uTime * 38.0;
                float nx = sin(noiseTime + pos.x * 23.541) * hash(pos.y * 124.52 + 125.214);
                float ny = cos(noiseTime + pos.y * 51.215) * hash(pos.x * 324.54 + 512.241);
                float nz = sin(noiseTime * 0.37) * hash(pos.z * 421.42 + 625.521);
                
                vec3 noise = vec3(nx, ny, nz) * intensity * 850.0;
                mvPosition.xyz += noise;
            }
            
            gl_Position = projectionMatrix * mvPosition;
            
            float pointSize = size * (320.0 / max(dist, 1.0));
            pointSize *= 0.53;

            if (isRing < 0.5 && dist < 36.0) {
                pointSize *= 0.825;
            }

            gl_PointSize = clamp(pointSize, 0.002, 285.0);

            vColor = customColor;
            vOpacity = opacityAttr;
            vScaleFactor = uScale;
            vIsRing = isRing;
        }
    </script>

    <script type="x-shader/x-fragment" id="fragmentshader">
        varying vec3 vColor;
        varying float vDist;
        varying float vOpacity;
        varying float vScaleFactor;
        varying float vIsRing;
        
        void main() {
            vec2 coord = 2.0 * gl_PointCoord - 1.0;
            float radius = dot(coord, coord);
            
            if (radius > 1.015) discard;
            
            float edgeFalloff = 0.39;
            float innerCore = 0.61;
            float glow = smoothstep(1.0, innerCore, radius);
            glow = pow(glow, 1.42);
            
            float scaleT = clamp((vScaleFactor - 0.09) / 2.49, 0.013, 1.0);

            vec3 deepSpaceColor = vec3(0.205, 0.148, 0.065);
            vec3 warmHighlight = vec3(0.96, 0.875, 0.735);
            
            float colorTransition = smoothstep(0.115, 0.915, scaleT);
            vec3 baseColor = mix(deepSpaceColor, vColor, colorTransition);

            float luminosity = 0.185 + 0.91 * scaleT;
            float density = 0.198 + 0.517 * smoothstep(0.019, 0.685, scaleT);

            vec3 finalColor = baseColor * luminosity;
            
            if (vDist < 35.0) {
                float proximity = 1.017 - (vDist / 351.0);
                proximity = clamp(proximity, 0.031, 1.0);
                
                if (vIsRing < 0.498) {
                    vec3 enhancedTexture = pow(vColor, vec3(1.315)) * 1.417;
                    finalColor = mix(finalColor, enhancedTexture, proximity * 0.715);
                } else {
                    finalColor += vec3(0.132, 0.105, 0.087) * proximity * 0.7;
                }
            }

            float depthFade = 1.0;
            if (vDist < 10.0) {
                depthFade = smoothstep(0.0, 10.0, vDist);
            }

            float alpha = glow * vOpacity * density * depthFade;
            
            gl_FragColor = vec4(finalColor, alpha);
        }
    </script>

     <script>
        // å…¨å±€å˜é‡
        let scene, camera, renderer, particles, stars, nebula;
        let planetGroup;
        let uniforms, starUniforms;
        
        // ç›®æ ‡å€¼ vs å½“å‰å€¼ (ç”¨äºå¹³æ»‘åŠ¨ç”»)
        let targetScale = 1.0;
        let targetRotX = 0.4;
        let currentScale = 1.0;
        let currentRotX = 0.4;
        
        // æ€§èƒ½ç›¸å…³å˜é‡
        let particleCount = 600000;
        let performanceMode = 'balanced';
        let isUIHidden = false;
        let isDataPanelVisible = true;
        let isHandDetected = false;
        let handTrackingEnabled = false;
        let lastHandDetectionTime = 0;
        
        // DOM å…ƒç´ 
        const videoElement = document.querySelector('.input_video');
        const statusElement = document.getElementById('status-indicator');
        const loadingOverlay = document.getElementById('loading-overlay');
        const loadingMessage = document.getElementById('loading-message');
        const fpsCounter = document.getElementById('fps-counter');
        const particleCountElement = document.getElementById('particle-count');
        const performanceModeElement = document.getElementById('performance-mode');
        const dataTimeElement = document.getElementById('data-time');
        const distanceEarthElement = document.getElementById('distance-earth');
        const gestureGuide = document.getElementById('gesture-guide');
        const saturnInfoPanel = document.getElementById('saturn-info-panel');
        const fullscreenBtn = document.getElementById('fullscreen-btn');
        const toggleUIbtn = document.getElementById('toggle-ui-btn');
        const resetViewBtn = document.getElementById('reset-view-btn');
        const toggleHandBtn = document.getElementById('toggle-hand-btn');
        
        // éŸ³ä¹æ§åˆ¶ç›¸å…³
        const backgroundMusic = document.getElementById('background-music');
        const musicToggle = document.getElementById('music-toggle');
        const volumeControl = document.getElementById('volume-control');
        
        // æ€§èƒ½ç›‘æ§
        let frameCount = 0;
        let lastFPSTime = performance.now();
        let currentFPS = 0;
        
        // æ‰‹åŠ¿è¯†åˆ«ç›¸å…³å˜é‡
        let handsInstance;
        let cameraStream;
        let autoOrbitPhase = 0;
        let isMusicPlaying = false;

        // ä¿®å¤1: æ·»åŠ ç¼ºå¤±çš„å‡½æ•°å®šä¹‰
        function showLoadingMessage(message) {
            if (loadingMessage) {
                loadingMessage.innerHTML = message;
            }
        }

        function showInfoPanel(message) {
            // ç®€å•çš„ä¿¡æ¯æç¤ºå®ç°
            console.log('Info:', message);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ä¿®å¤2: ç»Ÿä¸€å‡½æ•°å
        function initSaturnSystem() {
            // é‡å‘½åinitSaturnä¸ºinitSaturnSystemä»¥ä¿æŒä¸€è‡´æ€§
            initSaturn();
        }

        // åˆå§‹åŒ–Three.jsåœºæ™¯
        function initThree() {
            try {
                const container = document.getElementById('canvas-container');

                scene = new THREE.Scene();
                scene.fog = new THREE.FogExp2(0x020202, 0.00015);

                camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 10000);
                camera.position.z = 100;
                camera.lookAt(0, 0, 0);

                // åˆå§‹åŒ–åœŸæ˜Ÿç³»ç»Ÿ
                initSaturn();
                
                // åˆå§‹åŒ–èƒŒæ™¯æ˜Ÿç©º
                initStarfield();

                // åˆå§‹åŒ–èƒŒæ™¯å®ä½“è¡Œæ˜Ÿ
                initPlanets();

                renderer = new THREE.WebGLRenderer({ 
                    antialias: true, 
                    alpha: true,
                    powerPreference: "high-performance"
                });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                renderer.setClearColor(0x000000, 0); 
                container.appendChild(renderer.domElement);

                window.addEventListener('resize', onWindowResize);

                // æ€§èƒ½æ¨¡å¼é€‰æ‹©äº‹ä»¶
                document.querySelectorAll('input[name="performance"]').forEach(radio => {
                    radio.addEventListener('change', function() {
                        setPerformanceMode(this.value);
                    });
                });

                // å¼€å§‹æ¸²æŸ“å¾ªç¯
                startMainLoop();
                
                // æ›´æ–°çŠ¶æ€æŒ‡ç¤ºå™¨
                updateStatusIndicator("è‡ªåŠ¨å·¡èˆª", "ç­‰å¾…ä¸­...", "#666");
                
                // åˆå§‹åŒ–æ‰‹åŠ¿è¯†åˆ«
                initHandTracking();
                
                // æ›´æ–°åœŸæ˜Ÿæ•°æ®
                updateSaturnData();
                
                // åˆå§‹åŒ–éŸ³ä¹ç³»ç»Ÿ
                initMusicSystem();
                
                // æ˜¾ç¤ºå¼•å¯¼ç•Œé¢
                setTimeout(() => {
                    if (!handTrackingEnabled) {
                        showGestureGuide();
                    }
                }, 2000);
                
            } catch (error) {
                console.error('Three.jsåˆå§‹åŒ–é”™è¯¯:', error);
                showLoadingMessage("åˆå§‹åŒ–å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•");
            }
        }

        function initSaturn() {
            // æ ¹æ®æ€§èƒ½æ¨¡å¼è®¾ç½®ç²’å­æ•°é‡
            const configs = {
                'low': { count: 300000, label: '30ä¸‡' },
                'balanced': { count: 600000, label: '60ä¸‡' },
                'high': { count: 900000, label: '90ä¸‡' }
            };
            
            const config = configs[performanceMode] || configs.balanced;
            particleCount = config.count;
            
            if (particleCountElement) {
                particleCountElement.textContent = config.label;
            }
            if (performanceModeElement) {
                performanceModeElement.textContent = 
                    performanceMode === 'low' ? 'èŠ‚èƒ½' : 
                    performanceMode === 'balanced' ? 'å‡è¡¡' : 'é«˜å“è´¨';
            }

            const geometry = new THREE.BufferGeometry();
            
            // ç”³è¯·å†…å­˜
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);
            const opacities = new Float32Array(particleCount);
            const orbitSpeeds = new Float32Array(particleCount);
            const isRings = new Float32Array(particleCount);
            const randomIds = new Float32Array(particleCount);

            // åœŸæ˜Ÿæœ¬ä½“çš„è‰²è°ƒ
            const bodyColors = [
                new THREE.Color('#E3DAC5'), 
                new THREE.Color('#C9A070'), 
                new THREE.Color('#E3DAC5'), 
                new THREE.Color('#B08D55')  
            ];
            
            // åœŸæ˜Ÿç¯çš„å„å±‚é¢œè‰²
            const ringPalette = {
                C: new THREE.Color('#2A2520'), 
                B_inner: new THREE.Color('#CDBFA0'), 
                B_outer: new THREE.Color('#DCCBBA'), 
                Cassini: new THREE.Color('#050505'),
                A: new THREE.Color('#989085'), 
                F: new THREE.Color('#AFAFA0') 
            };

            const PLANET_RADIUS = 18;

            for(let i = 0; i < particleCount; i++) {
                randomIds[i] = Math.random();
                
                let isRingParticle = i >= particleCount * 0.25;
                isRings[i] = isRingParticle ? 1.0 : 0.0;
                
                if (!isRingParticle) {
                    // åœŸæ˜Ÿæœ¬ä½“ç²’å­
                    orbitSpeeds[i] = 0.0;
                    
                    const u = Math.random();
                    const v = Math.random();
                    const theta = 2.0 * Math.PI * u;
                    const phi = Math.acos(2.0 * v - 1.0);
                    const radius = PLANET_RADIUS;
                    
                    let x = radius * Math.sin(phi) * Math.cos(theta);
                    let rawY = radius * Math.cos(phi);
                    let z = radius * Math.sin(phi) * Math.sin(theta);
                    
                    // åœŸæ˜Ÿæ˜¯æ‰çš„ï¼Œå‹æ‰ä¸€ç‚¹ Y è½´
                    let y = rawY * 0.9;
                    
                    // ç”Ÿæˆæ¡çº¹å›¾æ¡ˆ
                    let lat = (rawY / radius + 1.0) * 0.5; 
                    let bandNoise = Math.cos(lat * 40.0) * 0.8 + Math.cos(lat * 15.0) * 0.4;
                    let colIndex = Math.floor(lat * 4 + bandNoise) % 4;
                    if (colIndex < 0) colIndex = 0;
                    let baseColor = bodyColors[colIndex];
                    
                    positions[i*3] = x;
                    positions[i*3+1] = y;
                    positions[i*3+2] = z;
                    
                    colors[i*3] = baseColor.r;
                    colors[i*3+1] = baseColor.g;
                    colors[i*3+2] = baseColor.b;
                    
                    sizes[i] = 1.0 + Math.random() * 0.8;
                    opacities[i] = 0.8;
                } else {
                    // åœŸæ˜Ÿç¯ç²’å­
                    let zoneSelector = Math.random();
                    let ringRadius, ringColor;
                    let sizeBase = 0.5, opacityBase = 0.3;
                    
                    if (zoneSelector < 0.15) {
                        // Cç¯
                        ringRadius = PLANET_RADIUS * (1.235 + Math.random() * (1.525 - 1.235));
                        ringColor = ringPalette.C;
                    } else if (zoneSelector < 0.65) {
                        // Bç¯
                        let t = Math.random();
                        ringRadius = PLANET_RADIUS * (1.525 + t * (1.95 - 1.525));
                        ringColor = ringPalette.B_inner.clone().lerp(ringPalette.B_outer, t);
                        sizeBase = 0.8 + Math.random() * 0.6;
                        opacityBase = 0.85;
                    } else if (zoneSelector < 0.69) {
                        // å¡è¥¿å°¼ç¼
                        ringRadius = PLANET_RADIUS * (1.95 + Math.random() * (2.025 - 1.95));
                        ringColor = ringPalette.Cassini;
                        sizeBase = 0.3; opacityBase = 0.1;
                    } else if (zoneSelector < 0.99) {
                        // Aç¯
                        ringRadius = PLANET_RADIUS * (2.025 + Math.random() * (2.27 - 2.025));
                        ringColor = ringPalette.A;
                        sizeBase = 0.7; opacityBase = 0.6;
                    } else {
                        // Fç¯
                        ringRadius = PLANET_RADIUS * (2.32 + Math.random() * 0.02);
                        ringColor = ringPalette.F;
                        sizeBase = 1.0; opacityBase = 0.7;
                    }
                    
                    const angle = Math.random() * Math.PI * 2;
                    let x = ringRadius * Math.cos(angle);
                    let z = ringRadius * Math.sin(angle);
                    
                    let thickness = 0.15;
                    if (ringRadius > PLANET_RADIUS * 2.3) thickness = 0.4;
                    let y = (Math.random() - 0.5) * thickness;
                    
                    positions[i*3] = x;
                    positions[i*3+1] = y;
                    positions[i*3+2] = z;
                    
                    colors[i*3] = ringColor.r;
                    colors[i*3+1] = ringColor.g;
                    colors[i*3+2] = ringColor.b;
                    
                    sizes[i] = sizeBase;
                    opacities[i] = opacityBase;
                    
                    // å¼€æ™®å‹’ç¬¬ä¸‰å®šå¾‹ï¼šè¶Šå¤–å±‚è½¬å¾—è¶Šæ…¢
                    orbitSpeeds[i] = 8.0 / Math.sqrt(ringRadius / PLANET_RADIUS);
                }
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('customColor', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            geometry.setAttribute('opacityAttr', new THREE.BufferAttribute(opacities, 1));
            geometry.setAttribute('orbitSpeed', new THREE.BufferAttribute(orbitSpeeds, 1));
            geometry.setAttribute('isRing', new THREE.BufferAttribute(isRings, 1));
            geometry.setAttribute('aRandomId', new THREE.BufferAttribute(randomIds, 1));

            uniforms = {
                uTime: { value: 0 },
                uScale: { value: currentScale },
                uRotationX: { value: currentRotX }
            };

            const material = new THREE.ShaderMaterial({
                depthWrite: false,
                blending: THREE.AdditiveBlending,
                vertexColors: true,
                uniforms: uniforms,
                vertexShader: document.getElementById('vertexshader').textContent,
                fragmentShader: document.getElementById('fragmentshader').textContent,
                transparent: true
            });

            particles = new THREE.Points(geometry, material);
            particles.rotation.z = 26.73 * (Math.PI / 180); // åœŸæ˜ŸçœŸå®çš„è½´å€¾è§’
            scene.add(particles);
        }

        function initStarfield() {
            const starCount = performanceMode === 'low' ? 20000 : 
                             performanceMode === 'balanced' ? 50000 : 80000;
            
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(starCount * 3);
            const colors = new Float32Array(starCount * 3);
            const sizes = new Float32Array(starCount);
            
            const spectralTypes = [
                new THREE.Color('#9bb0ff'),
                new THREE.Color('#ffffff'),
                new THREE.Color('#ffd280'),
                new THREE.Color('#ff7b7b')
            ];

            for(let i = 0; i < starCount; i++) {
                const distance = 400 + Math.random() * 3000;
                const azimuth = Math.random() * Math.PI * 2;
                const inclination = Math.acos(2.0 * Math.random() - 1.0);
                
                positions[i*3] = distance * Math.sin(inclination) * Math.cos(azimuth);
                positions[i*3+1] = distance * Math.cos(inclination);
                positions[i*3+2] = distance * Math.sin(inclination) * Math.sin(azimuth);
                
                const spectralRoll = Math.random();
                let stellarColor;
                if(spectralRoll > 0.9) stellarColor = spectralTypes[0];
                else if(spectralRoll > 0.6) stellarColor = spectralTypes[1];
                else if(spectralRoll > 0.3) stellarColor = spectralTypes[2];
                else stellarColor = spectralTypes[3];
                
                colors[i*3] = stellarColor.r;
                colors[i*3+1] = stellarColor.g;
                colors[i*3+2] = stellarColor.b;
                
                sizes[i] = 1.0 + Math.random() * 3.0;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('customColor', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            starUniforms = { uTime: { value: 0 } };
            
            const material = new THREE.ShaderMaterial({
                uniforms: starUniforms,
                vertexShader: `
                    attribute float size;
                    attribute vec3 customColor;
                    varying vec3 vColor;
                    uniform float uTime;
                    
                    void main() {
                        vColor = customColor;
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        gl_PointSize = size * (300.0 / length(mvPosition.xyz));
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;
                    void main() {
                        vec2 coord = gl_PointCoord - vec2(0.5);
                        if(length(coord) > 0.5) discard;
                        gl_FragColor = vec4(vColor, 1.0);
                    }
                `,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            stars = new THREE.Points(geometry, material);
            scene.add(stars);
        }

        function initPlanets() {
            planetGroup = new THREE.Group();
            scene.add(planetGroup);

            // ç®€åŒ–è¡Œæ˜Ÿåˆ›å»º
            const planets = [
                { color: 0xb33a00, radius: 10, position: new THREE.Vector3(-300, 120, -450) },
                { color: 0x001e4d, radius: 14, position: new THREE.Vector3(380, -100, -600) },
                { color: 0x666666, radius: 6, position: new THREE.Vector3(-180, -220, -350) }
            ];

            planets.forEach((planet, index) => {
                const geometry = new THREE.SphereGeometry(planet.radius, 32, 32);
                const material = new THREE.MeshBasicMaterial({
                    color: planet.color,
                    transparent: true,
                    opacity: 0.7
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.copy(planet.position);
                mesh.userData = { rotationSpeed: 0.05 + index * 0.02 };
                planetGroup.add(mesh);
            });
        }

        function initMusicSystem() {
            if (backgroundMusic && volumeControl) {
                backgroundMusic.volume = volumeControl.value;
                
                volumeControl.addEventListener('input', function() {
                    backgroundMusic.volume = this.value;
                });
            }
        }

        function toggleMusic() {
            if (!backgroundMusic) return;
            
            if (isMusicPlaying) {
                backgroundMusic.pause();
                if (musicToggle) {
                    musicToggle.innerHTML = '<span>ğŸ”‡</span><span>èƒŒæ™¯éŸ³ä¹</span>';
                }
            } else {
                backgroundMusic.play().catch(e => {
                    console.log('éŸ³ä¹æ’­æ”¾è¢«é˜»æ­¢:', e);
                });
                if (musicToggle) {
                    musicToggle.innerHTML = '<span>ğŸ”Š</span><span>æ’­æ”¾ä¸­</span>';
                }
            }
            isMusicPlaying = !isMusicPlaying;
        }

        // ä¿®å¤3: å®Œå–„æ‰‹åŠ¿è¯†åˆ«åˆå§‹åŒ–
        function initHandTracking() {
            try {
                if (typeof Hands === 'undefined') {
                    throw new Error('MediaPipe Handsåº“æœªåŠ è½½');
                }
                
                handsInstance = new Hands({
                    locateFile: (file) => {
                        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                    }
                });
                
                handsInstance.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.7,
                    minTrackingConfidence: 0.6
                });
                
                handsInstance.onResults(handleHandResults);
                
                // ä¿®å¤4: ä½¿ç”¨æ­£ç¡®çš„Cameraç±»
                const camera = new Camera(videoElement, {
                    onFrame: async () => {
                        if (handTrackingEnabled && videoElement.readyState >= 2) {
                            try {
                                await handsInstance.send({ image: videoElement });
                            } catch (err) {
                                console.warn('æ‰‹åŠ¿è¯†åˆ«å¤„ç†å¼‚å¸¸:', err);
                            }
                        }
                    },
                    width: 640,
                    height: 480
                });
                
                navigator.mediaDevices.getUserMedia({
                    video: { width: 640, height: 480, facingMode: 'user' },
                    audio: false
                }).then(stream => {
                    cameraStream = stream;
                    videoElement.srcObject = stream;
                    return camera.start();
                }).then(() => {
                    updateStatusIndicator("æ‰‹åŠ¨æ§åˆ¶", "ç­‰å¾…æ‰‹åŠ¿...", "#c5a059");
                }).catch(err => {
                    console.warn('æ‘„åƒå¤´è®¿é—®å¤±è´¥:', err);
                    fallbackToClassicControl();
                });
                
            } catch (error) {
                console.error('æ‰‹åŠ¿ç³»ç»Ÿåˆå§‹åŒ–å¤±è´¥:', error);
                fallbackToClassicControl();
            }
        }

        function handleHandResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                isHandDetected = true;
                lastHandDetectionTime = performance.now();
                
                const primaryHand = results.multiHandLandmarks[0];
                processHandGestures(primaryHand);
                
                updateStatusIndicator("æ‰‹åŠ¨æ§åˆ¶", "è·Ÿè¸ªä¸­", "#4CAF50");
                hideGestureGuide();
            } else {
                const timeSinceLastHand = performance.now() - lastHandDetectionTime;
                if (timeSinceLastHand > 3000) {
                    isHandDetected = false;
                    if (handTrackingEnabled) {
                        updateStatusIndicator("æ‰‹åŠ¨æ§åˆ¶", "ç­‰å¾…æ‰‹åŠ¿...", "#FF9800");
                        if (timeSinceLastHand > 5000) {
                            showGestureGuide();
                        }
                    }
                }
            }
        }

        function processHandGestures(handLandmarks) {
            const THUMB_TIP = 4;
            const INDEX_TIP = 8;
            const PALM_CENTER = 9;
            
            const thumb = handLandmarks[THUMB_TIP];
            const index = handLandmarks[INDEX_TIP];
            const palm = handLandmarks[PALM_CENTER];
            
            const pinchDistance = Math.sqrt(
                Math.pow(thumb.x - index.x, 2) + 
                Math.pow(thumb.y - index.y, 2)
            );
            
            let normalizedPinch = Math.max(0, Math.min(1, (pinchDistance - 0.05) / 0.3));
            normalizedPinch = Math.pow(normalizedPinch, 1.5);
            
            targetScale = 0.5 + normalizedPinch * (3.0 - 0.5);
            
            const palmVertical = Math.max(0, Math.min(1, (palm.y - 0.2) / 0.6));
            targetRotX = -1.0 + palmVertical * (1.0 - (-1.0));
            
            const smoothing = 0.1;
            targetScale = currentScale * (1 - smoothing) + targetScale * smoothing;
            targetRotX = currentRotX * (1 - smoothing) + targetRotX * smoothing;
        }

        function fallbackToClassicControl() {
            handTrackingEnabled = false;
            if (toggleHandBtn) {
                toggleHandBtn.textContent = 'æ‰‹åŠ¿æ§åˆ¶(ä¸å¯ç”¨)';
                toggleHandBtn.disabled = true;
            }
            
            document.addEventListener('wheel', handleMouseWheel);
            document.addEventListener('mousemove', handleMouseMove);
            updateStatusIndicator("è‡ªåŠ¨å·¡èˆª", "å°±ç»ª", "#59a0c5");
        }

        function handleMouseWheel(event) {
            event.preventDefault();
            const zoomSpeed = 0.1;
            const delta = Math.sign(event.deltaY) * zoomSpeed;
            targetScale = Math.max(0.5, Math.min(3.0, currentScale - delta));
        }

        let mouseDown = false;
        let lastMouseX = 0;
        let lastMouseY = 0;

        function handleMouseDown(event) {
            mouseDown = true;
            lastMouseX = event.clientX;
            lastMouseY = event.clientY;
        }

        function handleMouseUp() {
            mouseDown = false;
        }

        function handleMouseMove(event) {
            if (!mouseDown) return;
            
            const deltaX = event.clientX - lastMouseX;
            const deltaY = event.clientY - lastMouseY;
            
            const rotationSpeed = 0.01;
            targetRotX = Math.max(-1.0, Math.min(1.0, currentRotX - deltaY * rotationSpeed));
            
            lastMouseX = event.clientX;
            lastMouseY = event.clientY;
        }

        function setupEventListeners() {
            window.addEventListener('resize', onWindowResize);
            
            document.addEventListener('mousedown', handleMouseDown);
            document.addEventListener('mouseup', handleMouseUp);
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('wheel', handleMouseWheel);
            
            document.querySelectorAll('input[name="performance"]').forEach(radio => {
                radio.addEventListener('change', function() {
                    setPerformanceMode(this.value);
                });
            });
            
            document.addEventListener('keydown', (event) => {
                if (event.key === ' ') {
                    resetView();
                } else if (event.key === 'f' || event.key === 'F') {
                    toggleFullScreen();
                } else if (event.key === 'h' || event.key === 'H') {
                    toggleUI();
                } else if (event.key === 'm' || event.key === 'M') {
                    toggleMusic();
                } else if (event.key === 'Escape') {
                    if (document.fullscreenElement) {
                        document.exitFullscreen();
                    }
                }
            });
        }

        const globalClock = new THREE.Clock();
        let autoPilotPhase = 0;

        function startMainLoop() {
            function animate() {
                requestAnimationFrame(animate);
                
                const elapsedTime = globalClock.getElapsedTime();
                
                // æ›´æ–°uniforms
                if (uniforms) {
                    uniforms.uTime.value = elapsedTime;
                    uniforms.uScale.value = currentScale;
                    uniforms.uRotationX.value = currentRotX;
                }
                if (starUniforms) {
                    starUniforms.uTime.value = elapsedTime * 0.5;
                }
                
                // æ›´æ–°åœºæ™¯å¯¹è±¡
                if (stars) stars.rotation.y = elapsedTime * 0.005;
                if (planetGroup) {
                    planetGroup.rotation.y = Math.sin(elapsedTime * 0.05) * 0.02;
                    planetGroup.children.forEach(planet => {
                        planet.rotation.y += (planet.userData?.rotationSpeed || 0.05) * 0.05;
                    });
                }
                
                // è‡ªåŠ¨å·¡èˆªæ¨¡å¼
                if (!handTrackingEnabled || !isHandDetected) {
                    autoPilotPhase += 0.005;
                    targetScale = 1.0 + Math.sin(autoPilotPhase * 0.3) * 0.2;
                    targetRotX = 0.4 + Math.sin(autoPilotPhase * 0.2) * 0.15;
                    
                    if (!handTrackingEnabled) {
                        updateStatusIndicator("è‡ªåŠ¨å·¡èˆª", "æ¼”ç¤ºä¸­", "#59a0c5");
                    }
                }
                
                // å¹³æ»‘æ’å€¼
                const lerpFactor = 0.08;
                currentScale += (targetScale - currentScale) * lerpFactor;
                currentRotX += (targetRotX - currentRotX) * lerpFactor;
                
                // æ¸²æŸ“
                renderer.render(scene, camera);
                
                // æ›´æ–°æ€§èƒ½æŒ‡æ ‡å’Œæ•°æ®
                updatePerformanceMetrics();
                updateSaturnData();
                
                // éšè—åŠ è½½ç•Œé¢
                if (elapsedTime > 1 && loadingOverlay) {
                    loadingOverlay.style.opacity = '0';
                    if (elapsedTime > 1.5) {
                        loadingOverlay.style.display = 'none';
                    }
                }
            }
            
            animate();
        }

        function updatePerformanceMetrics() {
            frameCount++;
            const now = performance.now();
            const deltaTime = now - lastFPSTime;
            
            if (deltaTime >= 1000) {
                currentFPS = Math.round((frameCount * 1000) / deltaTime);
                frameCount = 0;
                lastFPSTime = now;
                
                if (fpsCounter) {
                    fpsCounter.textContent = `FPS: ${currentFPS} | ç²’å­: ${particleCountElement?.textContent || '--'}`;
                    fpsCounter.style.color = currentFPS < 30 ? '#ff9800' : 
                                           currentFPS < 15 ? '#f44336' : '#4CAF50';
                }
            }
        }

        function updateSaturnData() {
            const now = new Date();
            if (dataTimeElement) {
                dataTimeElement.textContent = now.toLocaleTimeString('zh-CN');
            }
            if (distanceEarthElement) {
                const hour = now.getHours();
                const distance = (12.8 + Math.sin(hour * Math.PI / 12) * 0.3).toFixed(1);
                distanceEarthElement.textContent = `${distance}äº¿å…¬é‡Œ`;
            }
        }

        function setPerformanceMode(mode) {
            performanceMode = mode;
            // é‡æ–°åˆå§‹åŒ–åœºæ™¯
            if (scene && particles) {
                scene.remove(particles);
                if (stars) scene.remove(stars);
                initSaturnSystem();
                initStarfield();
            }
        }

        function toggleFullScreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
                if (fullscreenBtn) {
                    fullscreenBtn.textContent = 'é€€å‡ºå…¨å±';
                    fullscreenBtn.classList.add('active');
                }
            } else {
                document.exitFullscreen();
                if (fullscreenBtn) {
                    fullscreenBtn.textContent = 'å…¨å±æ²‰æµ¸';
                    fullscreenBtn.classList.remove('active');
                }
            }
        }

        function toggleUI() {
            isUIHidden = !isUIHidden;
            const elements = [
                document.getElementById('ui-layer'),
                document.getElementById('performance-panel'),
                saturnInfoPanel
            ];
            
            elements.forEach(element => {
                if (element) {
                    element.style.opacity = isUIHidden ? '0' : '1';
                    element.style.pointerEvents = isUIHidden ? 'none' : 'auto';
                }
            });
            
            if (toggleUIbtn) {
                toggleUIbtn.textContent = isUIHidden ? 'æ˜¾ç¤ºç•Œé¢' : 'éšè—ç•Œé¢';
                toggleUIbtn.classList.toggle('active', isUIHidden);
            }
        }

        function toggleDataPanel() {
            isDataPanelVisible = !isDataPanelVisible;
            if (saturnInfoPanel) {
                saturnInfoPanel.style.display = isDataPanelVisible ? 'block' : 'none';
            }
        }

        function resetView() {
            targetScale = 1.0;
            targetRotX = 0.4;
            if (resetViewBtn) {
                resetViewBtn.classList.add('active');
                setTimeout(() => resetViewBtn.classList.remove('active'), 300);
            }
        }

        function toggleHandTracking() {
            handTrackingEnabled = !handTrackingEnabled;
            if (toggleHandBtn) {
                toggleHandBtn.textContent = handTrackingEnabled ? 'å…³é—­æ‰‹åŠ¿' : 'å¼€å¯æ‰‹åŠ¿';
                toggleHandBtn.classList.toggle('active', handTrackingEnabled);
            }
            
            if (handTrackingEnabled) {
                initHandTracking();
                updateStatusIndicator("æ‰‹åŠ¨æ§åˆ¶", "ç­‰å¾…æ‰‹åŠ¿...", "#c5a059");
                showGestureGuide();
            } else {
                updateStatusIndicator("è‡ªåŠ¨å·¡èˆª", "ç­‰å¾…ä¸­...", "#666");
                hideGestureGuide();
            }
        }

        function hideGestureGuide() {
            if (gestureGuide) gestureGuide.classList.add('hidden');
        }

        function showGestureGuide() {
            if (gestureGuide) gestureGuide.classList.remove('hidden');
        }

        function updateStatusIndicator(status, signal, color) {
            if (statusElement) {
                statusElement.innerHTML = `ç³»ç»ŸçŠ¶æ€: ${status}<br>è¾“å…¥ä¿¡å·: <span class="highlight">${signal}</span>`;
                statusElement.style.color = color;
            }
        }

        // åˆå§‹åŒ–åº”ç”¨
        window.addEventListener('load', function() {
            setupEventListeners();
            initThree();
        });
    </script>
</body>
</html>
